 ## Task List
- [ ] V0.0 全域環境與基建（一次性，完成後僅維護）
  - [ ] 作業系統與基本工具檢查
    - [ ] 開啟終端機確認可執行 `bash` 或對應 Shell
    - [ ] 在終端機輸入 `git --version` 確認已安裝 Git
    - [ ] 在終端機輸入 `node -v`，如非必要可略過 Node（僅 GitHub Pages 靜態頁需）
  - [ ] 安裝與驗證 WindSurf IDE
    - [ ] 在系統搜尋「WindSurf」嘗試啟動
    - [ ] 若可正常開啟則標記為已安裝
    - [ ] 若未安裝，前往官方頁面下載安裝 WindSurf（VS Code 架構）
    - [ ] 完成安裝後再次啟動 WindSurf 確認可用
  - [ ] 安裝與驗證 JDK 17
    - [ ] 在終端機輸入 `java -version`
    - [ ] 確認輸出版本字串包含 `17`
    - [ ] 若版本非 17，下載並安裝 Temurin/OpenJDK 17
    - [ ] 設定 `JAVA_HOME` 指向 JDK 安裝路徑
    - [ ] 將 `$JAVA_HOME/bin` 加入 `PATH`
    - [ ] 重新開啟終端機驗證 `java -version` 輸出為 17
  - [ ] 安裝與驗證 Android SDK Command-line tools
    - [ ] 在終端機輸入 `sdkmanager --list` 驗證是否可執行
    - [ ] 若指令不存在，下載 `commandlinetools-<os>-latest.zip`
    - [ ] 在家目錄建立 `~/Android/cmdline-tools/`
    - [ ] 將壓縮檔解至 `~/Android/cmdline-tools/latest`
    - [ ] 設定環境變數 `ANDROID_HOME=~/Android`
    - [ ] 將 `~/Android/platform-tools` 加入 `PATH`
    - [ ] 將 `~/Android/cmdline-tools/latest/bin` 加入 `PATH`
    - [ ] 在終端機輸入 `sdkmanager --licenses`
    - [ ] 於互動式流程接受所有授權條款
  - [ ] 安裝必要 Android SDK 元件
    - [ ] 在終端機執行 `sdkmanager "platform-tools"`
    - [ ] 在終端機執行 `sdkmanager "platforms;android-35"`
    - [ ] 在終端機執行 `sdkmanager "build-tools;35.0.0"`
    - [ ] 在終端機執行 `sdkmanager "emulator"`
    - [ ] 在終端機執行 `sdkmanager "system-images;android-35;google_apis;x86_64"`
  - [ ] 建立並驗證 AVD：Pixel6Api35
    - [ ] 在終端機執行 `avdmanager list avd | grep Pixel6Api35`
    - [ ] 若查無結果，執行 `avdmanager create avd -n Pixel6Api35 -k "system-images;android-35;google_apis;x86_64" -d pixel_6"`
    - [ ] 在終端機啟動模擬器 `emulator -avd Pixel6Api35 -netdelay none -netspeed full`
    - [ ] 另開終端機執行 `adb devices`
    - [ ] 確認列出一台 `emulator-` 開頭裝置狀態為 `device`
  - [ ] 設定 WindSurf 擴充套件
    - [ ] 開啟 WindSurf 擴充套件市集
    - [ ] 搜尋並安裝 Kotlin 擴充
    - [ ] 搜尋並安裝 Java Extension Pack
    - [ ] 搜尋並安裝 Gradle for Java
    - [ ] 搜尋並安裝 Android XML
    - [ ] 搜尋並安裝 ADB Interface
    - [ ] 搜尋並安裝 YAML
    - [ ] 搜尋並安裝 JSON
    - [ ] 搜尋並安裝 Markdown All in One
    - [ ] 搜尋並安裝 GitLens
    - [ ] 搜尋並安裝 Error Lens
    - [ ] 重新載入 WindSurf 驗證擴充已生效
  - [ ] 建立與設定 GitHub 專案與 GitHub Pages
    - [ ] 在 GitHub 建立 repo `masteryee-labs/AI-Destiny-Master`（或確認已存在）
    - [ ] 在本機建立資料夾 `~/work/aidestinymaster`
    - [ ] 在終端機執行 `git clone git@github.com:masteryee-labs/AI-Destiny-Master.git`
    - [ ] 進入目錄 `cd AI-Destiny-Master`
    - [ ] 建立資料夾 `docs`
    - [ ] 在 `docs` 建立 `index.md` 作為 Privacy Policy
    - [ ] 在 `docs` 建立 `terms.md` 作為 Terms of Service
    - [ ] 在 `docs` 建立 `support.md` 作為 Support
    - [ ] 在 `docs` 根目錄建立 `app-ads.txt`
    - [ ] 在 `app-ads.txt` 填入 `google.com, pub-1779359737796272, DIRECT, f08c47fec0942fa0`
    - [ ] 在 GitHub 專案設定開啟 Pages
    - [ ] 將 Pages 來源設為 `main` 分支 `/docs` 資料夾
    - [ ] 在瀏覽器開啟 Pages 網址確認可存取
  - [ ] 初始化 AdMob 與驗證網站（一次性）
    - [ ] 登入 AdMob 驗證帳號存在
    - [ ] 在 AdMob 建立 Android App（包名 `com.aidestinymaster`）
    - [ ] 確認 Rewarded 單元 ID `ca-app-pub-1779359737796272/5235603391` 可見
    - [ ] 在 AdMob 後台設定 `app-ads.txt` 網域為 GitHub Pages 網址
    - [ ] 在 AdMob 執行 `app-ads.txt` 驗證程序
    - [ ] 確認驗證狀態為通過
  - [ ] 設定 Play Console（帳號層級一次性）
    - [ ] 註冊 Google Play Developer 並完成付款
    - [ ] 建立商家帳戶（Merchant）並完成驗證
    - [ ] 新增開發者網站為 GitHub Pages 網址
    - [ ] 準備開發者聯絡 Email 並填入
- [ ] V1.0 基礎應用建置（西洋星盤 + AI 解析 + 付費 + 激勵廣告 + Coins + 恢復購買）
  - [ ] 專案骨架初始化（多模組 Gradle）
    - [ ] 在專案根目錄執行 `gradle wrapper`
    - [ ] 建立 `settings.gradle.kts`
    - [ ] 在 `settings.gradle.kts` 註冊 `:app`
    - [ ] 在 `settings.gradle.kts` 註冊 `:core:ai`
    - [ ] 在 `settings.gradle.kts` 註冊 `:core:astro`
    - [ ] 在 `settings.gradle.kts` 註冊 `:data`
    - [ ] 在 `settings.gradle.kts` 註冊 `:billing`
    - [ ] 在 `settings.gradle.kts` 註冊 `:ads`
    - [ ] 在 `settings.gradle.kts` 註冊 `:sync`
    - [ ] 建立根 `build.gradle.kts` 設定 Kotlin 版本與通用 repos
    - [ ] 在 `:app` 建立 `build.gradle.kts`
    - [ ] 在 `:core:ai` 建立 `build.gradle.kts`
    - [ ] 在 `:core:astro` 建立 `build.gradle.kts`
    - [ ] 在 `:data` 建立 `build.gradle.kts`
    - [ ] 在 `:billing` 建立 `build.gradle.kts`
    - [ ] 在 `:ads` 建立 `build.gradle.kts`
    - [ ] 在 `:sync` 建立 `build.gradle.kts`
  - [ ] Android 專案基本設定
    - [ ] 在 `:app` 啟用 Compose
    - [ ] 在 `:app` 設定 `compileSdk=35`
    - [ ] 在 `:app` 設定 `targetSdk=35`
    - [ ] 在 `:app` 設定 `minSdk=26`
    - [ ] 在 `:app` 設定 Kotlin 17 編譯
    - [ ] 在 `:app/src/main/AndroidManifest.xml` 加入 `INTERNET` 權限
    - [ ] 在 `:app/src/main/AndroidManifest.xml` 加入 `ACCESS_NETWORK_STATE` 權限
    - [ ] 在 `:app/src/main/AndroidManifest.xml` 加入 `POST_NOTIFICATIONS` 權限
    - [ ] 在 `:app/src/main/AndroidManifest.xml` 加入 `FOREGROUND_SERVICE` 權限
    - [ ] 在 `:app/src/main/AndroidManifest.xml` 加入 `FOREGROUND_SERVICE_DATA_SYNC` 權限
  - [ ] 相依套件導入與版本鎖定
    - [ ] 在 `:app` 加入 `implementation(platform("androidx.compose:compose-bom:2025.+" ))`
    - [ ] 在 `:app` 加入 `implementation("androidx.activity:activity-compose:<latest>")`
    - [ ] 在 `:app` 加入 `implementation("androidx.navigation:navigation-compose:<latest>")`
    - [ ] 在 `:data` 加入 `implementation("androidx.room:room-ktx:2.6.+")`
    - [ ] 在 `:data` 加入 `ksp("androidx.room:room-compiler:2.6.+")`
    - [ ] 在 `:data` 加入 `implementation("androidx.datastore:datastore-preferences:1.1.+")`
    - [ ] 在 `:app` 加入 `implementation("androidx.work:work-runtime-ktx:2.9.+")`
    - [ ] 在 `:app` 加入 `implementation("androidx.security:security-crypto:1.1.+")`
    - [ ] 在 `:core:ai` 加入 `implementation("com.microsoft.onnxruntime:onnxruntime-android:1.18.+")`
    - [ ] 在 `:billing` 加入 `implementation("com.android.billingclient:billing-ktx:8.+")`
    - [ ] 在 `:ads` 加入 `implementation("com.google.android.gms:play-services-ads:22.+")`
    - [ ] 在 共用模組加入 `implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")`
  - [ ] 資料層實作（Room／DataStore）
    - [ ] 在 `:data` 定義 Entity `Report`
    - [ ] 在 `:data` 定義 Entity `Chart`
    - [ ] 在 `:data` 定義 Entity `Wallet`
    - [ ] 在 `:data` 定義 Entity `Purchase`
    - [ ] 在 `:data` 建立 DAO `ReportDao`
    - [ ] 在 `:data` 建立 DAO `ChartDao`
    - [ ] 在 `:data` 建立 DAO `WalletDao`
    - [ ] 在 `:data` 建立 DAO `PurchaseDao`
    - [ ] 在 `:data` 建立 `AppDatabase` 並加入 migration v1
    - [ ] 在 `:data` 建立 Repository `ReportRepository`
    - [ ] 在 `:data` 建立 Repository `ChartRepository`
    - [ ] 在 `:data` 建立 Repository `WalletRepository`
    - [ ] 在 `:data` 建立 Repository `PurchaseRepository`
    - [ ] 在 `:data` 建立 `DataStore` `PreferencesKeys.language`
    - [ ] 在 `:data` 建立 `DataStore` `PreferencesKeys.theme`
    - [ ] 在 `:data` 建立 `DataStore` `PreferencesKeys.notificationEnabled`
  - [ ] DI 與 Service Locator
    - [ ] 在 `:app` 建立 `AppServices.kt`
    - [ ] 在 `AppServices.kt` 提供 `ReportRepository` 單例
    - [ ] 在 `AppServices.kt` 提供 `ChartRepository` 單例
    - [ ] 在 `AppServices.kt` 提供 `WalletRepository` 單例
    - [ ] 在 `AppServices.kt` 提供 `PurchaseRepository` 單例
    - [ ] 在 `AppServices.kt` 提供 `BillingManager` 單例
    - [ ] 在 `AppServices.kt` 提供 `AdsManager` 單例
  - [ ] :core:astro 星體計算
    - [ ] 在 `:core:astro` 引入 Astronomy Engine 原始碼或依賴
    - [ ] 建立資料類型 `PlanetPos`
    - [ ] 建立資料類型 `House`
    - [ ] 建立資料類型 `Aspect`
    - [ ] 建立 `AstroCalculator.kt` 實作 `computePlanets(julianDay)`
    - [ ] 建立 `HouseSystem.kt` 實作 `computeHouses(dateTime, tz, place)`
    - [ ] 建立 `Aspects.kt` 實作 `detectAspects(planets, orbDeg=6.0)`
    - [ ] 建立 `NatalChart` 資料類型
    - [ ] 建立 `NatalChartService.kt` 整合行星/宮位/相位
    - [ ] 寫單元測試：行星位置邏輯
    - [ ] 寫單元測試：相位偵測邏輯
    - [ ] 寫單元測試：宮位切法 Whole Sign
    - [ ] 寫單元測試：宮位切法 Porphyry
  - [ ] :core:ai ONNX TinyLlama（App 僅讀）
    - [ ] 在開發機下載 TinyLlama-1.1B-Chat 權重
    - [ ] 在開發機使用 `transformers` 導出 ONNX decoder-only
    - [ ] 在開發機使用 onnxruntime 進行 8-bit 量化
    - [ ] 產生 `tinyllama-chat-8bit.onnx`
    - [ ] 匯出 tokenizer 檔（SentencePiece 或 BPE）
    - [ ] 在 `:core:ai/src/main/assets/model/` 放入 `.onnx`
    - [ ] 在 `:core:ai/src/main/assets/model/` 放入 tokenizer 檔
    - [ ] 在 `:core:ai` 建立 `OnnxLlamaSession.kt`
    - [ ] 在 `OnnxLlamaSession.kt` 實作 `load(context): OrtSession`
    - [ ] 在 `OnnxLlamaSession.kt` 實作 assets 複製至 `files/` 與 SHA-256 校驗
    - [ ] 在 `OnnxLlamaSession.kt` 實作 `generate(prompt, params): Flow<String>`
    - [ ] 在 `OnnxLlamaSession.kt` 實作 `stop()`
    - [ ] 在 `:core:ai` 建立 `Tokenizer.kt`
    - [ ] 在 `Tokenizer.kt` 實作 `encode(text): IntArray`
    - [ ] 在 `Tokenizer.kt` 實作 `decodeIncremental(tokens): String`
    - [ ] 在 `:core:ai` 建立 `PromptBuilder.kt`
    - [ ] 在 `PromptBuilder.kt` 實作 `buildNatalReport(chartSummary, locale)`
    - [ ] 在模擬器 Pixel6Api35 測試生成 700 tokens 背景可完成
  - [ ] 背景任務與前景服務
    - [ ] 在 `:app` 建立 `ReportGenerationWorker.kt`
    - [ ] 在 `ReportGenerationWorker` 讀取 Chart
    - [ ] 在 `ReportGenerationWorker` 建立 Prompt
    - [ ] 在 `ReportGenerationWorker` 呼叫 `OnnxLlamaSession.generate()`
    - [ ] 在 `ReportGenerationWorker` 寫入加密 Report
    - [ ] 在 `ReportGenerationWorker` 送出完成通知
    - [ ] 在 `ReportGenerationWorker` 實作 `setForegroundAsync()` 提升
    - [ ] 在 `:app` 建立 `NotificationHelper.kt`
    - [ ] 在 `NotificationHelper` 建立通知頻道
    - [ ] 在通知點擊導向 `report.detail/{reportId}`
  - [ ] Billing v8 付款流程
    - [ ] 在 `:billing` 建立 `BillingManager.kt`
    - [ ] 在 `BillingManager` 實作 `startConnection()`
    - [ ] 在 `BillingManager` 實作 `queryPurchasesAsync()`
    - [ ] 在 `BillingManager` 實作 `launchPurchase(sku)`
    - [ ] 在 `BillingManager` 實作 `acknowledge(purchaseToken)`
    - [ ] 在 `BillingManager` 實作 `consume(purchaseToken)`
    - [ ] 在 `:billing` 定義 SKU `astro_deep_one`
    - [ ] 在 `:billing` 定義 SKU `sub_vip_month`
    - [ ] 在 `:billing` 定義 SKU `sub_vip_year`
    - [ ] 在 `:billing` 建立 `EntitlementStore`
    - [ ] 在 App 啟動呼叫 `queryPurchasesAsync()` 同步權益
  - [ ] AdMob Rewarded 與 Coins
    - [ ] 在 `:ads` 建立 `AdsManager.kt`
    - [ ] 在 `AdsManager` 實作 `initialize(context)`
    - [ ] 在 `AdsManager` 實作 `loadRewarded(adUnitId)`
    - [ ] 在 `AdsManager` 實作 `showRewarded(activity)`
    - [ ] 在 `:app` 建立 `CoinsService.kt`
    - [ ] 在 `CoinsService` 實作 `earn(amount)`
    - [ ] 在 `CoinsService` 實作 `spend(amount)`
    - [ ] 在 `CoinsService` 實作 每小時 3 次 限制
    - [ ] 在 `CoinsService` 實作 每日 8 次 限制
    - [ ] 在 `:ads` 建立 `ConsentManager.kt`
    - [ ] 在 `ConsentManager` 載入 UMP 同意表單
    - [ ] 在 `ConsentManager` 成功同意後允許請求廣告
  - [ ] 共用 UI 主題與導航骨架（V1 全局樣式）
    - [ ] 在 `:app` 建立 `ui/theme/Color.kt`
    - [ ] 在 `:app` 建立 `ui/theme/Typography.kt`
    - [ ] 在 `:app` 建立 `ui/theme/Theme.kt`
    - [ ] 在 `:app` 建立 `ui/navigation/NavGraph.kt`
    - [ ] 在 `NavGraph.kt` 定義 route `home`
    - [ ] 在 `NavGraph.kt` 定義 route `chart.input`
    - [ ] 在 `NavGraph.kt` 定義 route `chart.result`
    - [ ] 在 `NavGraph.kt` 定義 route `report.detail`
    - [ ] 在 `NavGraph.kt` 定義 route `wallet`
    - [ ] 在 `NavGraph.kt` 定義 route `settings`
    - [ ] 在 `NavGraph.kt` 定義 route `purchase`
    - [ ] 在 `:app` 建立 `ui/components/BottomBar.kt`
    - [ ] 在 `BottomBar` 建立項目「首頁」
    - [ ] 在 `BottomBar` 建立項目「報告」
    - [ ] 在 `BottomBar` 建立項目「錢包」
    - [ ] 在 `BottomBar` 建立項目「設定」
  - [ ] UI/UX 畫面與互動（V1 版位固定，日後版本沿用邏輯）
    - [ ] 建立 `OnboardingScreen`
    - [ ] 在 `OnboardingScreen` 顯示條款同意勾選框
    - [ ] 在 `OnboardingScreen` 顯示隱私權同意勾選框
    - [ ] 在 `OnboardingScreen` 顯示「下一步」按鈕
    - [ ] 在 `OnboardingScreen` 第二步顯示出生日期日期選擇器
    - [ ] 在 `OnboardingScreen` 顯示出生時間時間選擇器
    - [ ] 在 `OnboardingScreen` 顯示時區下拉選單
    - [ ] 在 `OnboardingScreen` 顯示地點下拉（城市列表）
    - [ ] 在 `OnboardingScreen` 顯示「啟用通知」切換
    - [ ] 在 `OnboardingScreen` 顯示「開始使用」按鈕
    - [ ] 建立 `HomeScreen`
    - [ ] 在 `HomeScreen` 上方放置「快速排盤」Filled Button
    - [ ] 在 `HomeScreen` 中段建立「我的近期報告」橫向卡片列表
    - [ ] 在 `HomeScreen` 建立卡片「生成 AI 詳解」
    - [ ] 在 `HomeScreen` 建立卡片「今日黃曆（占位）」標示即將推出
    - [ ] 在 `HomeScreen` 建立卡片「我的點數／購買」顯示 Coins 餘額
    - [ ] 在 `HomeScreen` 將底部列顯示為固定
    - [ ] 建立 `ChartInputScreen`
    - [ ] 在 `ChartInputScreen` 放置日期選擇器元件
    - [ ] 在 `ChartInputScreen` 放置時間選擇器元件
    - [ ] 在 `ChartInputScreen` 放置時區下拉選單元件
    - [ ] 在 `ChartInputScreen` 放置地點下拉選單元件
    - [ ] 在 `ChartInputScreen` 放置「生成星盤」主要按鈕
    - [ ] 在 `ChartInputScreen` 禁用主要按鈕於欄位未填時
    - [ ] 建立 `ChartResultScreen`
    - [ ] 在 `ChartResultScreen` 使用 Compose Canvas 繪製盤面
    - [ ] 在 `ChartResultScreen` 顯示相位矩陣表格
    - [ ] 在 `ChartResultScreen` 放置「生成 AI 詳解（可背景）」主要按鈕
    - [ ] 在 `ChartResultScreen` 放置二級按鈕「分享盤面」
    - [ ] 在 `ChartResultScreen` 按下主要按鈕觸發 `ReportGenerationWorker`
    - [ ] 在 `ChartResultScreen` 顯示背景生成中提示
    - [ ] 建立 `ReportDetailScreen`
    - [ ] 在 `ReportDetailScreen` 顯示重點摘要卡
    - [ ] 在 `ReportDetailScreen` 顯示長文折疊區塊
    - [ ] 在 `ReportDetailScreen` 放置「分享」按鈕
    - [ ] 在 `ReportDetailScreen` 放置解鎖 CTA（單次／訂閱／用幣）
    - [ ] 在 `ReportDetailScreen` 未解鎖狀態遮罩長文
    - [ ] 建立 `WalletScreen`
    - [ ] 在 `WalletScreen` 顯示 Coins 餘額數字
    - [ ] 在 `WalletScreen` 放置「看廣告 +10 幣」按鈕
    - [ ] 在 `WalletScreen` 於冷卻中禁用按鈕
    - [ ] 在 `WalletScreen` 超額顯示限制提示
    - [ ] 建立 `SettingsScreen`
    - [ ] 在 `SettingsScreen` 放置語言選擇
    - [ ] 在 `SettingsScreen` 放置主題切換
    - [ ] 在 `SettingsScreen` 放置通知開關
    - [ ] 在 `SettingsScreen` 放置「恢復購買」按鈕
    - [ ] 建立 `PurchaseScreen`
    - [ ] 在 `PurchaseScreen` 顯示商品列表
    - [ ] 在 `PurchaseScreen` 為每商品放置「購買」按鈕
    - [ ] 在 `PurchaseScreen` 放置「恢復購買」按鈕
    - [ ] 在 `PurchaseScreen` 完成購買顯示 Snackbar 權益變更
    - [ ] 在所有畫面加入頂部 App Bar 顯示標題
    - [ ] 在所有畫面遵循 Material 3 間距與可觸區
  - [ ] 互動流程串接（V1 端到端）
    - [ ] 在 `HomeScreen` 點擊「快速排盤」導向 `chart.input`
    - [ ] 在 `ChartInputScreen` 點擊「生成星盤」寫入 `Chart` 到 DB
    - [ ] 在 `ChartInputScreen` 完成後導向 `chart.result/{chartId}`
    - [ ] 在 `ChartResultScreen` 點擊「生成 AI 詳解」檢查解鎖狀態
    - [ ] 在 `ChartResultScreen` 若 VIP 或已購買則直接呼叫 Worker
    - [ ] 在 `ChartResultScreen` 若未解鎖則彈出解鎖方式選單
    - [ ] 在 `ReportGenerationWorker` 生成完成後透過通知提示
    - [ ] 在 通知點擊導向 `report.detail/{reportId}`
    - [ ] 在 `ReportDetailScreen` 點擊「分享」建立分享 Intent
    - [ ] 在 `WalletScreen` 點擊「看廣告 +10 幣」呼叫 `AdsManager.showRewarded()`
    - [ ] 在 `AdsManager` 回呼 `onUserEarnedReward` 呼叫 `CoinsService.earn(10)`
    - [ ] 在 消耗 50 幣時呼叫 `CoinsService.spend(50)` 並記錄消耗
  - [ ] 安全與加密
    - [ ] 在 `ReportRepository` 實作 AES-GCM 加密 `Report.content`
    - [ ] 在 App 啟動校驗模型與 tokenizer 的 SHA-256
    - [ ] 在 `ReportDetailScreen` 顯示「僅供參考／非專業建議」警語
  - [ ] 商店與法遵準備（V1）
    - [ ] 撰寫繁中短描述（50 字內）
    - [ ] 撰寫繁中長描述（首三行含核心關鍵詞）
    - [ ] 撰寫英文短描述
    - [ ] 撰寫英文長描述
    - [ ] 擷取 6 張功能對應截圖（首頁／排盤／結果／報告／錢包／設定）
    - [ ] 檢查標題與描述避免商標詞
    - [ ] 在 GitHub Pages 確認隱私政策 URL 可存取
    - [ ] 填寫 Data Safety（本機處理／Billing／Ads）
  - [ ] 簽章與建置
    - [ ] 在終端機執行 `keytool -genkey -v -keystore aidd.keystore -alias aidd -keyalg RSA -keysize 2048 -validity 10000`
    - [ ] 在本機 `gradle.properties` 設定簽章資訊
    - [ ] 在終端機執行 `./gradlew clean`
    - [ ] 在終端機執行 `./gradlew bundleRelease`
    - [ ] 確認輸出 `app-release.aab` 產生
  - [ ] Play Console 建置（首次上架準備到 Internal 測試）
    - [ ] 在 Play Console 建立應用名稱「AI命理大師：西洋星盤・AI解盤」
    - [ ] 設定預設語言為繁中
    - [ ] 填寫開發者資訊與聯絡 Email
    - [ ] 新增隱私權政策 URL
    - [ ] 完成內容分級問卷
    - [ ] 完成 Data Safety
    - [ ] 在「應用內產品」建立 `astro_deep_one`
    - [ ] 在「應用內產品」建立 `sub_vip_month`
    - [ ] 在「應用內產品」建立 `sub_vip_year`
    - [ ] 新增 Internal 測試人員名單
    - [ ] 建立 Internal 釋出並上傳 `app-release.aab`
    - [ ] 填寫版本更新說明
  - [ ] 測試與灰度
    - [ ] 使用測試帳安裝並啟動 App
    - [ ] 在 API 26 模擬器跑一輪核心流程
    - [ ] 在 API 28 模擬器跑一輪核心流程
    - [ ] 在 API 30 模擬器跑一輪核心流程
    - [ ] 在 API 33 模擬器跑一輪核心流程
    - [ ] 在 API 35 模擬器跑一輪核心流程
    - [ ] 測試：排盤成功寫入 DB
    - [ ] 測試：AI 報告背景生成不中斷
    - [ ] 測試：廣告成功觀看與發幣
    - [ ] 測試：半途離開不發幣
    - [ ] 測試：冷卻與每日上限生效
    - [ ] 測試：單次購買成功與 `acknowledge`
    - [ ] 測試：訂閱成功與權益同步
    - [ ] 測試：恢復購買成功
    - [ ] 驗證 `targetSdk=35` 與 64-bit
    - [ ] 建立 Closed 測試（必要時）
    - [ ] 建立 Open 測試（必要時）
    - [ ] 進行灰度 10% 上線
    - [ ] 使用 Crash/ANR 監控 48 小時
    - [ ] 視監控結果擴大至 100%
- [ ] V1.1 Google 雲端同步（沿用 V1 UI 模式，設定頁新增開關）
  - [ ] OAuth Debug 設定（Google Cloud Console）
    - [ ] 在瀏覽器登入 Google Cloud Console（使用將要發布 App 的同一組開發者帳號）
    - [ ] 在頂部搜尋列輸入 `APIs & Services` 並開啟
    - [ ] 在左側選單點擊 `Credentials`
    - [ ] 點擊上方 `+ CREATE CREDENTIALS` 下拉選 `OAuth client ID`
    - [ ] 若尚未建立同意畫面則按導引先建立 OAuth 同意畫面（外部或內部均可，先選外部以利測試）
    - [ ] 在 OAuth 同意畫面 `App information` 輸入應用名稱（與 Play Console 一致）
    - [ ] 在 OAuth 同意畫面 `User support email` 選擇開發者 Email
    - [ ] 在 OAuth 同意畫面 `App domain` 的 `Privacy policy link` 暫填 GitHub Pages 隱私權政策 URL
    - [ ] 在 OAuth 同意畫面 `Authorized domains` 新增 GitHub Pages 網域（例：`masteryee-labs.github.io`）
    - [ ] 在 OAuth 同意畫面 `Scopes` 保持最小範圍（可先空白，之後自動加入 drive.appdata）
    - [ ] 在 OAuth 同意畫面 `Test users` 新增內測帳號 Email（至少一個）
    - [ ] 儲存並返回 `Credentials`
    - [ ] 點擊 `+ CREATE CREDENTIALS` 選擇 `OAuth client ID`
    - [ ] 在 `Application type` 選擇 `Android`
    - [ ] 在 `Name` 輸入 `Android Debug`
    - [ ] 在 `Package name` 輸入 `com.aidestinymaster`
    - [ ] 在 `SHA-1 certificate fingerprint` 貼上 Debug SHA-1 `4C:31:F8:77:F4:8F:9A:7A:29:9F:2E:DD:61:A3:54:57:B8:E2:D8:A3`
    - [ ] 點擊 `Create` 並等待顯示 Client ID
    - [ ] 複製並記錄 Android 用戶端 ID `486797680754-o57bjhvdvt0bfu6abm54sf3qa36j9rhf.apps.googleusercontent.com`
    - [ ] 返回 `APIs & Services > Enabled APIs & services`
    - [ ] 點擊 `+ ENABLE APIS AND SERVICES`
    - [ ] 搜尋 `Google Drive API` 並點擊進入
    - [ ] 點擊 `ENABLE` 以啟用 Drive API 供專案使用
  - [ ] OAuth Release 設定（Google Cloud Console）
    - [ ] 在本機以發行 keystore 產出 Release SHA-1（於終端機執行 `keytool -list -v -keystore aidd.keystore -alias aidd` 並輸入密碼）
    - [ ] 複製 `SHA1` 值並備註為 Release SHA-1
    - [ ] 返回 Google Cloud Console `Credentials`
    - [ ] 點擊 `+ CREATE CREDENTIALS` 選擇 `OAuth client ID`
    - [ ] 在 `Application type` 選擇 `Android`
    - [ ] 在 `Name` 輸入 `Android Release`
    - [ ] 在 `Package name` 輸入 `com.aidestinymaster`
    - [ ] 在 `SHA-1 certificate fingerprint` 貼上 Release SHA-1
    - [ ] 點擊 `Create` 完成建立 Release Android OAuth
    - [ ] 開啟 `OAuth consent screen` 頁籤
    - [ ] 在 `App domain` 的 `Privacy policy link` 更新為已上線之 GitHub Pages 隱私政策 URL
    - [ ] 在 `Authorized domains` 確認已包含隱私政策所屬網域
    - [ ] 在 `Scopes` 區塊新增/確認 `https://www.googleapis.com/auth/drive.appdata` 範圍
    - [ ] 在 `Test users` 保留測試 Email（發行前可改為送審，必要時提升至生產）
    - [ ] 儲存並發布同意畫面（若需要，將狀態從測試切換為生產）
  - [ ] App 端 Google Sign-In 串接（play-services-auth）
    - [ ] 在 `:app/build.gradle.kts` 確認已加入 `implementation("com.google.android.gms:play-services-auth:21.+")`
    - [ ] 在 `AndroidManifest.xml` `application` 內確認存在網路權限與正確的 `package` 名稱 `com.aidestinymaster`
    - [ ] 在 `SettingsScreen` 對應的 ViewModel 新增狀態 `syncEnabled: StateFlow<Boolean>` 與 `syncStatus: StateFlow<String>`
    - [ ] 在 `:app` 建立檔案 `auth/GoogleAuth.kt` 作為登入封裝
    - [ ] 在 `GoogleAuth.kt` 新增函式 `fun buildGSO(context): GoogleSignInOptions`
    - [ ] 在 `buildGSO` 設定 `requestEmail()`
    - [ ] 在 `buildGSO` 設定 `requestScopes(Scope("https://www.googleapis.com/auth/drive.appdata"))`
    - [ ] 在 `GoogleAuth.kt` 新增函式 `fun getClient(context): GoogleSignInClient`
    - [ ] 在登入流程新增 `ActivityResultLauncher` 以啟動 `getClient(context).signInIntent`
    - [ ] 在登入回傳的 `onActivityResult` 或 `ActivityResultCallback` 解析 `GoogleSignIn.getSignedInAccountFromIntent(data)`
    - [ ] 在解析成功後取得 `GoogleSignInAccount` 物件並保存至 `AuthState`（含 `email`, `grantedScopes`）
    - [ ] 在 `AuthState` 新增函式 `suspend fun getAccessToken(context): String` 使用 `GoogleAuthUtil.getToken(context, account.account, "oauth2:https://www.googleapis.com/auth/drive.appdata")` 以取得存取權杖
    - [ ] 在 `AuthState` 捕捉 `UserRecoverableAuthException` 並透過 `startActivityForResult` 觸發授權補救流程
    - [ ] 在 `SettingsScreen` 畫面新增「登入 Google 帳號」按鈕（初次或登出狀態顯示）
    - [ ] 在「登入 Google 帳號」按鈕點擊時呼叫 `getClient(context).signInIntent`
    - [ ] 在登入成功後將 UI 切換為顯示帳號 Email 與同步開關
    - [ ] 在 `SettingsScreen` 畫面新增「登出」按鈕（已登入狀態顯示）
    - [ ] 在「登出」按鈕點擊時呼叫 `GoogleSignIn.getClient(context, gso).signOut()` 並清除 `AuthState`
  - [ ] Drive REST v3 客戶端（以 REST + OkHttp 實作 appDataFolder 存取）
    - [ ] 在 `:sync` 模組建立套件 `com.aidestinymaster.sync.drive`
    - [ ] 在 `:sync/build.gradle.kts` 新增 `implementation("com.squareup.okhttp3:okhttp:<latest>")`
    - [ ] 在 `:sync/build.gradle.kts` 確認 `implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")`
    - [ ] 在 `:sync` 建立 `DriveModels.kt` 定義 `DriveFile`（id,name,modifiedTime）
    - [ ] 在 `:sync` 建立 `DriveEndpoints.kt` 常數 `BASE_URL = "https://www.googleapis.com/drive/v3/"`
    - [ ] 在 `DriveEndpoints.kt` 定義 `FILES_LIST = "files"`
    - [ ] 在 `DriveEndpoints.kt` 定義 `UPLOAD_CREATE = "upload/drive/v3/files?uploadType=multipart"`
    - [ ] 在 `DriveEndpoints.kt` 定義 `FILES_UPDATE = "upload/drive/v3/files/{fileId}?uploadType=multipart"`
    - [ ] 在 `:sync` 建立 `DriveHttp.kt` 建立 `OkHttpClient` 與共用 `User-Agent`
    - [ ] 在 `DriveHttp.kt` 實作 `fun authHeader(token:String) = "Bearer $token"`
    - [ ] 在 `DriveHttp.kt` 實作 `suspend fun get(url:String, token:String): Response`
    - [ ] 在 `DriveHttp.kt` 實作 `suspend fun multipartCreate(metaJson:String, dataBytes:ByteArray, token:String): Response`
    - [ ] 在 `DriveHttp.kt` 實作 `suspend fun multipartUpdate(fileId:String, metaJson:String, dataBytes:ByteArray, token:String): Response`
    - [ ] 在 `:sync` 建立 `DriveService.kt`
    - [ ] 在 `DriveService.kt` 實作 `suspend fun findFileIdByName(name:String, token:String): String?`（呼叫 `files.list` 參數 `spaces=appDataFolder`, `q=name='xxx'`, `fields=files(id,name,modifiedTime)`）
    - [ ] 在 `DriveService.kt` 實作 `suspend fun download(name:String, token:String): String?`（先查 `id`，再呼叫 `GET https://www.googleapis.com/drive/v3/files/{id}?alt=media`）
    - [ ] 在 `DriveService.kt` 實作 `suspend fun uploadOrMerge(name:String, json:String, encrypted:Boolean, token:String): String`（若無檔則 `create`，有檔則 `update`；皆指定 `parents=["appDataFolder"]`）
    - [ ] 在 `DriveService.kt` 處理錯誤碼 `401/403` 觸發重新登入或重新要求授權
    - [ ] 在 `DriveService.kt` 對 `429/5xx` 實作指數退避重試
    - [ ] 在 `DriveService.kt` 對 `If-Match`（Etag）或 `modifiedTime` 做衝突保護（優先較新）
    - [ ] 在 `:sync` 建立 `Crypto.kt` 使用 `Security Crypto` AES-GCM 封裝 `encrypt(bytes): ByteArray`、`decrypt(bytes): ByteArray`
    - [ ] 在 `Crypto.kt` 建立 `MasterKey` 初始化與本機 Keystore 綁定
    - [ ] 在 `:sync` 建立 `SyncRepository.kt`
    - [ ] 在 `SyncRepository.kt` 注入 `DriveService`、本地 `ReportRepository`、`WalletRepository`、`PurchaseRepository`
    - [ ] 在 `SyncRepository.kt` 實作 `suspend fun pullAll(token:String)` 下載 `reports.json`、`wallet.json`、`purchases.json`
    - [ ] 在 `SyncRepository.kt` 實作 `suspend fun pushAll(token:String)` 上傳三檔（敏感欄位先經 AES-GCM）
    - [ ] 在 `SyncRepository.kt` 實作 `fun merge(local:List<T>, remote:List<T>): List<T>` 以 `updatedAt` 較新者覆蓋
    - [ ] 在 `SyncRepository.kt` 對 `reports.json` 實作欄位層級合併（以 `id` 為鍵）
    - [ ] 在 `SyncRepository.kt` 對 `wallet.json` 實作餘額與日誌合併（以 `updatedAt` 與 `opId` 去重）
    - [ ] 在 `SyncRepository.kt` 對 `purchases.json` 實作權益清單去重合併（以 `purchaseToken` 唯一）
    - [ ] 在 `:sync` 建立 `SyncUseCases.kt` 封裝 `oneShotSync(token)`、`continuousSync(token)`
    - [ ] 在 `:sync` 建立 `SyncStatus.kt` 狀態列舉 `Idle`、`Syncing`、`Success`、`Error(message)`
  - [ ] 設定頁 UI 調整（沿用 V1 UI 版位，新增同步區塊）
    - [ ] 在 `SettingsScreen` 新增卡片區塊「雲端同步」
    - [ ] 在卡片內上方顯示目前登入帳號（未登入顯示「未登入」）
    - [ ] 在卡片內左側放置「登入 Google 帳號」主要按鈕（未登入時顯示）
    - [ ] 在卡片內左側放置「登出」次要按鈕（已登入時顯示）
    - [ ] 在卡片內右側放置「雲端同步」開關（僅已登入時可用）
    - [ ] 在卡片底部顯示狀態列文字 `上次同步：yyyy/MM/dd HH:mm` 或錯誤訊息
    - [ ] 在開啟「雲端同步」開關時觸發 `oneShotSync(token)` 進行首次上傳/下載與合併
    - [ ] 在開啟後於 App 冷啟時自動執行 `continuousSync(token)`（前景/網路可用時）
    - [ ] 在同步進行中於 UI 顯示 `LinearProgressIndicator`
    - [ ] 在同步成功後顯示 `Snackbar("同步完成")`
    - [ ] 在同步失敗時顯示 `Snackbar("同步失敗：{message}")`
  - [ ] 邏輯串接與權限流轉
    - [ ] 在 App 啟動流程檢查 `GoogleSignIn.getLastSignedInAccount(context)`
    - [ ] 若帳號存在且已授權 `drive.appdata` 將 `syncEnabled` 從 DataStore 載入並恢復開關狀態
    - [ ] 若 `syncEnabled=true` 則於 App 啟動後 5 秒啟動背景 `oneShotSync`（避免啟動競態）
    - [ ] 在 `ReportRepository`、`WalletRepository`、`PurchaseRepository` 之 `insert/update` 成功後標記 `dirty=true`
    - [ ] 在 `continuousSync` 定時（例如每 30 分鐘）檢查是否有 `dirty` 再觸發增量上傳
  - [ ] 測試與上架更新（同步功能）
    - [ ] 在 裝置A：登入 Google → 開啟同步 → 新增一筆 `Report` → 關網路 → 編輯該 `Report` 並儲存
    - [ ] 在 裝置A：恢復網路 → 觀察自動推送至雲端 → 狀態顯示 `同步完成`
    - [ ] 在 裝置B：登入同帳號 → 開啟同步 → 觀察自動下載與合併 → 查看 `Report` 為較新版本
    - [ ] 在 裝置A/B：同時離線各自修改同一 `Report` → 恢復網路 → 驗證以 `updatedAt` 較新者覆蓋
    - [ ] 在 內購與點數：分別於兩裝置修改 → 同步後檢查權益與餘額一致
    - [ ] 在 同意畫面：確認隱私政策連結可開啟與網域授權正確
    - [ ] 在 商店頁：更新描述新增「Google 帳號同步」並擷取設定頁新截圖
    - [ ] 產生新 `app-release.aab` → 上傳 Internal 測試 → 用測試帳驗證登入與同步閉環
- [ ] V2.0 每日星座／個人化運勢（離線生成，復用 V1 UI 模式）
  - [ ] 基礎資料與服務建立
    - [ ] 在 `:core:astro` 建立 `DailyTransitService.kt`
    - [ ] 在 `DailyTransitService` 新增 `fun computeFor(date: LocalDate, natal: NatalChart): DailyTransit`
    - [ ] 在 `DailyTransitService` 新增 `fun summarize(transit: DailyTransit): String`（輸出重點摘要）
    - [ ] 在 `:data` 建立 `DailyReport` Entity（id,date,summary,detail,updatedAt）
    - [ ] 在 `:data` 建立 `DailyReportDao` 與查詢 `by date`
    - [ ] 在 `:data` 建立 `DailyReportRepository`
  - [ ] 排程與背景生成
    - [ ] 在 `:app` 建立 `DailyReportWorker.kt`
    - [ ] 在 `DailyReportWorker` 讀取預設個人盤 `NatalChart`
    - [ ] 在 `DailyReportWorker` 呼叫 `DailyTransitService.computeFor(today, natal)`
    - [ ] 在 `DailyReportWorker` 呼叫 `summarize` 產出 `summary`
    - [ ] 在 `DailyReportWorker` 寫入 `DailyReportRepository.upsert`
    - [ ] 在 `DailyReportWorker` 發送完成廣播或事件
    - [ ] 在 `:app` 建立 `WorkScheduler.kt` 計算距離次日 06:00 的初次延遲
    - [ ] 在 `WorkScheduler` 註冊 `PeriodicWorkRequest` 每 24 小時執行（近似 06:00）
  - [ ] UI/UX：Home 卡片
    - [ ] 在 `HomeScreen` 新增「今日運勢卡」區塊（置於「近期報告」卡片之上）
    - [ ] 在卡片左側顯示 `summary` 一行至兩行（溢出省略）
    - [ ] 在卡片右上方顯示日期 `yyyy/MM/dd`
    - [ ] 在卡片右下方放置主要按鈕「查看長文」
    - [ ] 在卡片右下方主要按鈕被點擊時導向 `daily.detail/{date}`
    - [ ] 在 `NavGraph` 新增 route `daily.detail/{date}`
    - [ ] 在 `DailyDetailScreen` 顯示長文 `detail`
    - [ ] 在 `DailyDetailScreen` 顯示分享按鈕（分享文字不含個資）
  - [ ] 付費門檻與權益控制
    - [ ] 在 `EntitlementStore` 新增 `isVIP: StateFlow<Boolean>`
    - [ ] 在 `DailyDetailScreen` 若 `isVIP=true` 直接顯示全文
    - [ ] 在 `DailyDetailScreen` 若 `isVIP=false` 顯示解鎖條（50 幣或看 5 支廣告）
    - [ ] 在 解鎖條「看廣告」按鈕呼叫 `AdsManager.showRewarded()` 累計至 5 支後解鎖一次
    - [ ] 在 解鎖條「用幣解鎖」按鈕呼叫 `CoinsService.spend(50)` 成功則解鎖
  - [ ] 通知
    - [ ] 在 `NotificationHelper` 新增頻道 `DAILY_TIPS`
    - [ ] 在 `DailyReportWorker` 完成後排程 08:00 發送 `今日重點` 通知
    - [ ] 在 通知點擊導向 `daily.detail/{date}`
  - [ ] 測試
    - [ ] 模擬器調整系統時間至次日 06:05 驗證 Worker 觸發與資料寫入
    - [ ] 驗證 VIP 與非 VIP 的解鎖邏輯與 UI
    - [ ] 驗證 08:00 通知與點擊導向
    - [ ] 擷取新截圖並更新商店描述加入「今日運勢卡」
- [ ] V3.0 每日黃曆卡（本地規則）
  - [ ] 規則與資料
    - [ ] 在 WindSurf 檔案總管建立目錄 `:app/src/main/assets/almanac`
    - [ ] 在 `:app/src/main/assets/almanac` 建立空白檔案 `AlmanacRules.json`
    - [ ] 在 `AlmanacRules.json` 輸入 JSON 陣列骨架 `[]`
    - [ ] 在 `AlmanacRules.json` 新增欄位結構範例物件 `{"date":"YYYY-MM-DD","solarTerm":"string","good":["string"],"bad":["string"],"tips":"string"}`
    - [ ] 在 `AlmanacRules.json` 加入至少 7 天測試資料（連續日期，含不同 `good` 與 `bad` 項目各 3+ 筆）
    - [ ] 在 WindSurf 終端機執行 `./gradlew :app:assembleDebug` 驗證 assets 無語法錯誤（若失敗修正 JSON）
    - [ ] 在 `:core` 建立套件 `core.almanac`
    - [ ] 在 `:core` 建立檔案 `AlmanacModels.kt`
    - [ ] 在 `AlmanacModels.kt` 定義 `data class AlmanacEntry(val date: LocalDate, val solarTerm: String?, val good: List<String>, val bad: List<String>, val tips: String?)`
    - [ ] 在 `AlmanacModels.kt` 定義 `object AlmanacConstants { const val FILE_PATH = "almanac/AlmanacRules.json"; const val MAX_WORD = 6 }`
    - [ ] 在 `:core` 建立檔案 `AlmanacService.kt`
    - [ ] 在 `AlmanacService.kt` 匯入 `kotlinx.serialization` 與 `java.time.LocalDate`
    - [ ] 在 `AlmanacService.kt` 定義 `object AlmanacService`
    - [ ] 在 `AlmanacService.kt` 新增私有函式 `private fun load(context: Context): List<AlmanacEntry>`
    - [ ] 在 `AlmanacService.kt` 的 `load` 以 `context.assets.open(AlmanacConstants.FILE_PATH)` 讀取檔案
    - [ ] 在 `AlmanacService.kt` 的 `load` 使用 `Json{ ignoreUnknownKeys = true }` 反序列化為 `List<AlmanacEntry>`
    - [ ] 在 `AlmanacService.kt` 新增快取欄位 `private var cache: Map<LocalDate, AlmanacEntry>? = null`
    - [ ] 在 `AlmanacService.kt` 新增私有函式 `private fun ensureCache(context: Context)`
    - [ ] 在 `AlmanacService.kt` 的 `ensureCache` 將清單轉 `associateBy { it.date }` 指派給 `cache`
    - [ ] 在 `AlmanacService.kt` 新增公開函式 `fun forDate(context: Context, date: LocalDate): AlmanacEntry?`
    - [ ] 在 `AlmanacService.kt` 的 `forDate` 先呼叫 `ensureCache(context)` 再回傳 `cache?.get(date)`
    - [ ] 在 `AlmanacService.kt` 新增安全回退 `fun fallback(date: LocalDate): AlmanacEntry`（無規則時提供空白 good/bad 與提示）
    - [ ] 在 `:core` 建立檔案 `AlmanacText.kt`
    - [ ] 在 `AlmanacText.kt` 新增 `fun clamp6(text: String): String = if (text.codePointCount(0, text.length) <= AlmanacConstants.MAX_WORD) text else text.substring(0, text.offsetByCodePoints(0, AlmanacConstants.MAX_WORD))`
    - [ ] 在 `:core` 建立單元測試檔 `AlmanacServiceTest.kt`
    - [ ] 在 `AlmanacServiceTest.kt` 寫測試 `載入 JSON 成功時 forDate 回傳對應日期`
    - [ ] 在 `AlmanacServiceTest.kt` 寫測試 `缺資料時 fallback 回傳空白 good/bad`
    - [ ] 在 `AlmanacServiceTest.kt` 寫測試 `clamp6 對中英文混排能安全截斷不破壞字元`
    - [ ] 在 WindSurf 終端機執行 `./gradlew test` 驗證測試通過
  - [ ] UI/UX：Home 黃曆卡
    - [ ] 在 `:app` 開啟 `ui/navigation/NavGraph.kt`
    - [ ] 在 `NavGraph.kt` 確認既有 `home`、`daily` 區塊存在
    - [ ] 在 `NavGraph.kt` 新增常數路由字串 `const val ROUTE_ALMANAC_MONTH = "almanac.month"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_ALMANAC_MONTH) { AlmanacMonthScreen() }`
    - [ ] 在 `:app` 建立檔案 `ui/components/AlmanacCard.kt`
    - [ ] 在 `AlmanacCard.kt` 定義 `@Composable fun AlmanacCard(today: LocalDate, onOpenMonth: () -> Unit)`
    - [ ] 在 `AlmanacCard.kt` 的卡片最上方顯示標題文字「今日黃曆」
    - [ ] 在 `AlmanacCard.kt` 取得 `val entry = AlmanacService.forDate(context, today) ?: AlmanacService.fallback(today)`
    - [ ] 在 `AlmanacCard.kt` 建立一列 `Row` 顯示「宜」圖標與三個 `Text`
    - [ ] 在 `AlmanacCard.kt` 的每個 `Text` 套用 `maxLines = 1` 與 `overflow = TextOverflow.Ellipsis`
    - [ ] 在 `AlmanacCard.kt` 的每個 `Text` 內容呼叫 `clamp6(item)` 後顯示
    - [ ] 在 `AlmanacCard.kt` 建立第二列 `Row` 顯示「忌」圖標與三個 `Text` 以相同規則
    - [ ] 在 `AlmanacCard.kt` 於卡片右下方加入 `TextButton` 文案「查看月曆」
    - [ ] 在 `AlmanacCard.kt` 的 `TextButton` 點擊時呼叫 `onOpenMonth()`
    - [ ] 在 `:app` 開啟 `ui/screens/HomeScreen.kt`
    - [ ] 在 `HomeScreen.kt` 找到「今日運勢卡」所在 Composable 區塊
    - [ ] 在「今日運勢卡」下一個位置插入 `AlmanacCard(today = LocalDate.now()) { navController.navigate(ROUTE_ALMANAC_MONTH) }`
    - [ ] 在 `HomeScreen.kt` 確認卡片使用 Material 3 樣式與 16dp 外距
    - [ ] 在 `HomeScreen.kt` 確認無任何 Debug-only 元件或隱藏入口
  - [ ] UI/UX：AlmanacMonthScreen
    - [ ] 在 `:app` 建立檔案 `ui/screens/AlmanacMonthScreen.kt`
    - [ ] 在 `AlmanacMonthScreen.kt` 定義 `@Composable fun AlmanacMonthScreen()`
    - [ ] 在 `AlmanacMonthScreen.kt` 上方加入 `TopAppBar` 標題「黃曆月檢視」
    - [ ] 在 `AlmanacMonthScreen.kt` 右側 `TopAppBar` 加入月份切換 IconButton「上一月」
    - [ ] 在 `AlmanacMonthScreen.kt` 右側 `TopAppBar` 加入月份切換 IconButton「下一月」
    - [ ] 在 `AlmanacMonthScreen.kt` 使用 `LazyColumn` 顯示 1~31 日清單
    - [ ] 在 `AlmanacMonthScreen.kt` 的每列 `item` 顯示日期 `MM/dd(E)`、三個「宜」項目、三個「忌」項目、以及單行 `tips` 省略號
    - [ ] 在 `AlmanacMonthScreen.kt` 的每列右側放置 `OutlinedButton` 文案「查看」
    - [ ] 在 `AlmanacMonthScreen.kt` 的「查看」點擊導向 `daily.detail/{date}`（若已實作每日詳文）
    - [ ] 在 `AlmanacMonthScreen.kt` 列首加入 `Divider()` 分隔各天
    - [ ] 在 `AlmanacMonthScreen.kt` 讀取每日資料 `AlmanacService.forDate(context, date) ?: fallback(date)`
    - [ ] 在 `AlmanacMonthScreen.kt` 所有字串使用 `clamp6` 與 `maxLines=1` 避免換行
  - [ ] 付費控制與文案
    - [ ] 在 `:data` 建立資料表 `AlmanacUnlock` 欄位 `id(UUID)`, `date(LocalDate)`, `unlockedAt(Instant)`
    - [ ] 在 `:data` 建立 `AlmanacUnlockDao` 含 `isUnlocked(date)` 與 `insert(unlock)`
    - [ ] 在 `:data` 建立 `AlmanacUnlockRepository` 封裝查詢與新增
    - [ ] 在 `:app` 開啟 `EntitlementStore` 確認有 `isVIP: StateFlow<Boolean>`
    - [ ] 在 `AlmanacMonthScreen.kt` 取得 `isVIP` 狀態
    - [ ] 在 `AlmanacMonthScreen.kt` 每列加入解鎖條區域（僅 `isVIP=false` 且 `!isUnlocked(date)` 顯示）
    - [ ] 在 解鎖條區域顯示文案「單日解鎖 50 幣」
    - [ ] 在 解鎖條區域放置主要按鈕「用幣解鎖」
    - [ ] 在 「用幣解鎖」點擊呼叫 `CoinsService.spend(50)` 成功則 `AlmanacUnlockRepository.insert(date)`
    - [ ] 在 `AlmanacMonthScreen.kt` 若 `isVIP=true` 直接隱藏所有解鎖條並顯示完整內容
    - [ ] 在 `AlmanacMonthScreen.kt` 解鎖成功後以 `Snackbar("已解鎖本日")` 提示
    - [ ] 在 `AlmanacMonthScreen.kt` 退出重進後驗證 `isUnlocked(date)` 仍為已解鎖
  - [ ] 測試
    - [ ] 在 模擬器設定系統日期切換至有資料的 3 個日期逐一檢視卡片顯示
    - [ ] 在 Home 黃曆卡驗證三個「宜」與三個「忌」截斷規則與省略號
    - [ ] 在 月檢視頁向左切換至上一月時所有日期仍能 fallback 顯示
    - [ ] 在 非 VIP 身份點擊「用幣解鎖」扣除 50 幣後顯示完整內容
    - [ ] 在 重新啟動 App 後再次進入相同日期仍為已解鎖狀態
    - [ ] 在 VIP 身份直接顯示整月內容無解鎖條
    - [ ] 擷取 Home 黃曆卡截圖 1080x1920
    - [ ] 擷取 月檢視頁截圖 1080x1920
    - [ ] 更新商店描述文案新增關鍵詞「黃曆卡」「月檢視」
- [ ] V4.0 紫微斗數（基礎命盤 + AI）
  - [ ] 引擎
    - [ ] 在 `:core` 建立套件 `core.ziwei`
    - [ ] 在 `:core` 建立檔案 `ZiweiModels.kt`
    - [ ] 在 `ZiweiModels.kt` 定義 `data class Palace(val name: String, val index: Int)`
    - [ ] 在 `ZiweiModels.kt` 定義 `data class Star(val name: String, val palaceIndex: Int, val weight: Int)`
    - [ ] 在 `ZiweiModels.kt` 定義 `data class ZiweiChart(val palaces: List<Palace>, val stars: List<Star>)`
    - [ ] 在 `:core` 建立檔案 `ZiweiEngine.kt`
    - [ ] 在 `ZiweiEngine.kt` 實作 `fun computeChart(birth: ZonedDateTime): ZiweiChart`
    - [ ] 在 `ZiweiEngine.kt` 建立十二宮清單與基本排布（命、兄、夫、子、財、疾、遷、僕、官、田、福、父）
    - [ ] 在 `ZiweiEngine.kt` 實作主星落宮簡化規則（以出生時辰與月令映射，先放置 5~8 顆示意主星）
    - [ ] 在 `:app/src/main/assets/ziwei` 建立 `ZiweiGlossary.json`
    - [ ] 在 `ZiweiGlossary.json` 定義結構 `{"star":"string","meaning":"string"}` 陣列
    - [ ] 在 `ZiweiGlossary.json` 為每顆主星新增 1~2 句釋義
    - [ ] 在 `:core` 建立檔案 `ZiweiGlossary.kt` 載入 `ZiweiGlossary.json` 並提供 `fun meaning(star:String): String?`
    - [ ] 在 `:core` 建立單元測試 `ZiweiEngineTest.kt` 驗證十二宮數量與主星數量大於 0
  - [ ] UI/UX
    - [ ] 在 `NavGraph.kt` 新增常數 `const val ROUTE_ZIWEI_CHART = "ziwei.chart"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_ZIWEI_CHART) { ZiweiChartScreen() }`
    - [ ] 在 `:app` 建立檔案 `ui/screens/ZiweiChartScreen.kt`
    - [ ] 在 `ZiweiChartScreen.kt` 放置 `TopAppBar` 標題「紫微命盤」
    - [ ] 在 `ZiweiChartScreen.kt` 使用 `LazyVerticalGrid` 以 3x4 方格呈現十二宮
    - [ ] 在 `ZiweiChartScreen.kt` 每格上方顯示宮名 `Palace.name`
    - [ ] 在 `ZiweiChartScreen.kt` 每格中段以 `FlowRow` 顯示該宮主星名稱（最多 4 個，超出以 `+n`）
    - [ ] 在 `ZiweiChartScreen.kt` 底部置中加入主要按鈕「生成 AI 詳解」
    - [ ] 在 `HomeScreen.kt` 新增入口卡片「紫微命盤」按鈕導向 `ROUTE_ZIWEI_CHART`
    - [ ] 在 `ZiweiChartScreen.kt` 確認所有版位遵循 Material 3 與 V1 間距
  - [ ] AI 串接與付費
    - [ ] 在 `:core:ai` 開啟 `PromptBuilder.kt`
    - [ ] 在 `PromptBuilder.kt` 新增 `fun buildZiweiReport(chart: ZiweiChart, glossary: (String)->String?): String`
    - [ ] 在 `PromptBuilder.kt` 的模板加入各宮重點與主星釋義占位
    - [ ] 在 `:billing` 新增 SKU 常數 `ZIWEI_DEEP_ONE = "ziwei_deep_one"`
    - [ ] 在 `:app` 的 `PurchaseScreen` 新增商品卡 `ziwei_deep_one`
    - [ ] 在 `ZiweiChartScreen.kt` 按下「生成 AI 詳解」時檢查是否已擁有 `ziwei_deep_one` 或 `isVIP`
    - [ ] 在 未擁有時彈出購買流程 `BillingManager.launchPurchase(ZIWEI_DEEP_ONE)`
    - [ ] 在 擁有或 VIP 時建立 `ReportGenerationWorker` 任務並帶入 `PromptBuilder.buildZiweiReport`
    - [ ] 在 生成完成通知點擊導向 `report.detail/{reportId}`
  - [ ] 測試
    - [ ] 在 模擬器輸入固定出生資料生成命盤並檢視 12 宮渲染
    - [ ] 在 點擊「生成 AI 詳解」未購買時導向購買並完成付款
    - [ ] 在 付款後再次點擊直接生成並於 `ReportDetailScreen` 顯示長文
    - [ ] 在 商店頁更新關鍵詞「紫微斗數」並擷取兩張截圖
- [ ] V5.0 八字（四柱／十神／喜忌 + AI）
  - [ ] 引擎
    - [ ] 在 `:core` 建立套件 `core.bazi`
    - [ ] 在 `:core` 的 `build.gradle.kts` 新增 `implementation("com.nlf.calendar:lunar-java:<latest>")`
    - [ ] 在 `:core` 建立檔案 `BaziModels.kt`
    - [ ] 在 `BaziModels.kt` 定義 `data class Pillar(val heavenlyStem:String, val earthlyBranch:String)`
    - [ ] 在 `BaziModels.kt` 定義 `data class BaziChart(val year:Pillar, val month:Pillar, val day:Pillar, val hour:Pillar)`
    - [ ] 在 `BaziModels.kt` 定義 `data class Scores(val fiveElements: Map<String, Int>, val tenGods: Map<String, Int>)`
    - [ ] 在 `:core` 建立檔案 `BaziEngine.kt`
    - [ ] 在 `BaziEngine.kt` 實作 `fun computeChart(birth: ZonedDateTime): BaziChart` 以 `lunar-java` 轉四柱
    - [ ] 在 `BaziEngine.kt` 實作 `fun evaluate(chart: BaziChart): Scores` 計分五行與十神
    - [ ] 在 `:core` 建立單元測試 `BaziEngineTest.kt` 驗證固定生日四柱輸出與分數和大於 0
  - [ ] UI/UX
    - [ ] 在 `NavGraph.kt` 新增常數 `const val ROUTE_BAZI_CHART = "bazi.chart"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_BAZI_CHART){ BaziChartScreen() }`
    - [ ] 在 `:app` 建立檔案 `ui/screens/BaziChartScreen.kt`
    - [ ] 在 `BaziChartScreen.kt` 放置 `TopAppBar` 標題「八字排盤」
    - [ ] 在 `BaziChartScreen.kt` 上半區塊以四列顯示 年柱、月柱、日柱、時柱
    - [ ] 在 `BaziChartScreen.kt` 下半區塊顯示五行雷達或條狀簡表（純文字百分比）
    - [ ] 在 `BaziChartScreen.kt` 底部置中加入主要按鈕「生成 AI 詳解」
    - [ ] 在 `HomeScreen.kt` 新增入口卡片「八字排盤」導向 `ROUTE_BAZI_CHART`
  - [ ] 付費與測試
    - [ ] 在 `:billing` 新增 SKU 常數 `BAZI_DEEP_ONE = "bazi_deep_one"`
    - [ ] 在 `PurchaseScreen` 新增商品卡 `bazi_deep_one`
    - [ ] 在 `BaziChartScreen.kt` 按下「生成 AI 詳解」時檢查是否已擁有 `bazi_deep_one` 或 `isVIP`
    - [ ] 在 未擁有時啟動 `BillingManager.launchPurchase(BAZI_DEEP_ONE)`
    - [ ] 在 擁有或 VIP 時以 `PromptBuilder.buildBaziReport(chart, scores)` 建立 Prompt 並呼叫 `ReportGenerationWorker`
    - [ ] 在 模擬器驗證四柱正確、AI 長文生成、購買解鎖流程
    - [ ] 在 商店頁更新關鍵詞「八字」「四柱」並擷取截圖
- [ ] V6.0 能量圖（人類圖替代名）+ AI
  - [ ] 資料與畫布
    - [ ] 在 `:app/src/main/assets/energy` 建立 `EnergyMapMapper.json`
    - [ ] 在 `EnergyMapMapper.json` 定義結構 `{"gate":1,"name":"G1","theme":"string","desc":"string"}` 陣列（1~64）
    - [ ] 在 `:core` 建立套件 `core.energy`
    - [ ] 在 `:core` 建立檔案 `EnergyModels.kt` 定義 `data class Gate(val id:Int, val name:String, val theme:String, val desc:String)`
    - [ ] 在 `:core` 建立檔案 `EnergyRepo.kt` 載入 `EnergyMapMapper.json` 並提供 `fun allGates(): List<Gate>`
    - [ ] 在 `:app` 建立檔案 `ui/canvas/EnergyMapCanvas.kt`
    - [ ] 在 `EnergyMapCanvas.kt` 定義 `@Composable fun EnergyMapCanvas(gates: List<Gate>)`
    - [ ] 在 `EnergyMapCanvas.kt` 使用 `Canvas(modifier = Modifier.fillMaxWidth().height(360.dp))`
    - [ ] 在 `EnergyMapCanvas.kt` 繪製人體輪廓簡化圖形（頭心喉等節點以圓與線連接）
    - [ ] 在 `EnergyMapCanvas.kt` 於對應節點旁以 `drawContext.canvas.nativeCanvas` 渲染 gate 簡碼
  - [ ] UI/UX 與文案
    - [ ] 在 `NavGraph.kt` 新增常數 `const val ROUTE_ENERGY_MAP = "energy.map"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_ENERGY_MAP){ EnergyMapScreen() }`
    - [ ] 在 `:app` 建立檔案 `ui/screens/EnergyMapScreen.kt`
    - [ ] 在 `EnergyMapScreen.kt` 放置 `TopAppBar` 標題「能量圖（非官方）」與副標「僅供參考」
    - [ ] 在 `EnergyMapScreen.kt` 上半部顯示 `EnergyMapCanvas(gates)`
    - [ ] 在 `EnergyMapScreen.kt` 下半部以 `LazyColumn` 顯示 64 閘門列表（名稱、主題、摘要）
    - [ ] 在 `HomeScreen.kt` 新增入口卡片「能量圖」導向 `ROUTE_ENERGY_MAP`
    - [ ] 在 `EnergyMapScreen.kt` 確認畫面無任何 Debug-only 控制
  - [ ] 付費
    - [ ] 在 `:billing` 新增 SKU 常數 `ENERGY_DEEP_ONE = "energy_deep_one"`
    - [ ] 在 `PurchaseScreen` 新增商品卡 `energy_deep_one`
    - [ ] 在 `EnergyMapScreen.kt` 底部加入主要按鈕「生成 AI 詳解」
    - [ ] 在 按鈕點擊檢查是否已擁有 `energy_deep_one` 或 `isVIP` 才允許生成
    - [ ] 在 允許生成時以 `PromptBuilder.buildEnergyReport(gates)` 建立 Prompt 並呼叫 `ReportGenerationWorker`
  - [ ] 測試
    - [ ] 在 模擬器檢視 Canvas 繪製效能於中階裝置 60fps 以上
    - [ ] 在 調整螢幕密度與深色模式下圖形不變形與文字可讀
    - [ ] 在 購買後可直接生成 AI 長文，未購買會導向購買
    - [ ] 在 AI 文案確保未出現商標詞（Human Design／BodyGraph 等）
- [ ] V7.0 綜合 AI 總結（多體系合流）
  - [ ] 資料結構與儲存（不新增模組，放現有模組內）
    - [ ] 在 `:data` 新增檔 `entity/FusionReport.kt` 定義 `data class FusionReport(id: String, createdAt: Instant, period: String, overview: String, crossThemes: List<String>, risks: List<String>, actions30: List<String>, actions90: List<String>, rawPromptHash: String, tokens:Int)`
    - [ ] 在 `:data` 新增 `dao/FusionReportDao.kt` 定義 `insert(FusionReport)`, `getById(id)`, `listRecent(limit:Int)`, `deleteOlderThan(days:Int)`
    - [ ] 在 `:data` 的 `AppDatabase` 加入 `abstract fun fusionReportDao(): FusionReportDao`
    - [ ] 在 `:data` 新增 `repository/FusionReportRepository.kt` 封裝 `suspend fun upsert(report: FusionReport)`, `suspend fun recent(limit:Int):List<FusionReport>`
  - [ ] 服務層（多體系合流）
    - [ ] 在 `:core` 建立套件 `core.fusion`
    - [ ] 在 `core.fusion` 建立 `FusionModels.kt` 定義
    - [ ] 在 `FusionModels.kt` 定義 `data class FusionInput(natal:NatalChart?, ziwei:ZiweiChart?, bazi:BaziChart?, energy:List<Gate>?)`
    - [ ] 在 `FusionModels.kt` 定義 `data class FusionSummary(natal:String, ziwei:String, bazi:String, energy:String)`
    - [ ] 在 `FusionModels.kt` 定義 `data class FusionOutput(overview:String, crossThemes:List<String>, risks:List<String>, actions30:List<String>, actions90:List<String>)`
    - [ ] 在 `core.fusion` 建立 `FusionGatherer.kt` 提供 `suspend fun gather(userId:String): FusionInput`
    - [ ] 在 `FusionGatherer.kt` 讀取本地 DB 最近一次 `NatalChart`，若無則回傳 `null`
    - [ ] 在 `FusionGatherer.kt` 讀取最近一次 `ZiweiChart`，若無則回傳 `null`
    - [ ] 在 `FusionGatherer.kt` 讀取最近一次 `BaziChart`，若無則回傳 `null`
    - [ ] 在 `FusionGatherer.kt` 讀取最近一次 `EnergyMap`（已選閘門/預設映射），若無則回傳 `null`
    - [ ] 在 `core.fusion` 建立 `FusionSummarizer.kt` 提供 `fun summarize(input:FusionInput): FusionSummary`
    - [ ] 在 `FusionSummarizer.kt` 對 `natal` 呼叫既有摘要器（若無則以規則詞庫取前三重點）
    - [ ] 在 `FusionSummarizer.kt` 對 `ziwei` 呼叫 `ZiweiGlossary.meaning` 組合 3 條重點敘述
    - [ ] 在 `FusionSummarizer.kt` 對 `bazi` 根據五行分數輸出 3 條重點敘述
    - [ ] 在 `FusionSummarizer.kt` 對 `energy` 取前 3 個關鍵閘門主題敘述
    - [ ] 在 `core.fusion` 建立 `FusionPromptBuilder.kt` 提供 `fun build(summary:FusionSummary, locale:Locale): String`
    - [ ] 在 `FusionPromptBuilder.kt` 模板加入：`[概覽]`、`[交叉主題]`、`[風險]`、`[30天行動]`、`[90天行動]` 段落標題
    - [ ] 在 `core.fusion` 建立 `FusionGenerator.kt` 提供 `suspend fun generate(summary:FusionSummary): FusionOutput`
    - [ ] 在 `FusionGenerator.kt` 以 `OnnxLlamaSession.generate(prompt)` 取得流式輸出並解析為段落
    - [ ] 在 `FusionGenerator.kt` 將每段以標頭切分放入 `FusionOutput`
    - [ ] 在 `core.fusion` 建立單元測試 `FusionPromptBuilderTest.kt` 驗證必含 5 個段落標頭
    - [ ] 在 `core.fusion` 建立單元測試 `FusionGeneratorParseTest.kt` 給定固定輸出字串能解析成 5 區塊
  - [ ] 背景任務與權益檢查
    - [ ] 在 `:app` 建立 `workers/FusionReportWorker.kt`
    - [ ] 在 `FusionReportWorker.kt` `doWork()` 先查 `EntitlementStore.isVIP` 或是否擁有 `fusion_deep_one`
    - [ ] 在 無權益時回傳 `Result.failure(Data().putString("needPurchase","true"))`
    - [ ] 在 `FusionReportWorker.kt` 取得 `FusionInput` → `FusionSummary` → `FusionOutput`
    - [ ] 在 `FusionReportWorker.kt` 建立 `FusionReport` 寫入 `FusionReportRepository.upsert`
    - [ ] 在 `FusionReportWorker.kt` 發送完成通知，點擊導向 `fusion.report/{reportId}`
  - [ ] 路由與畫面
    - [ ] 在 `:app/ui/navigation/NavGraph.kt` 新增常數 `const val ROUTE_FUSION_REPORT = "fusion.report/{reportId}"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_FUSION_REPORT){ backStack -> FusionReportScreen(reportId = backStack.arguments?.getString("reportId")!!) }`
    - [ ] 在 `:app/ui/screens` 建立 `FusionReportScreen.kt`
    - [ ] 在 `FusionReportScreen.kt` 置頂 `TopAppBar` 標題「綜合 AI 總結」
    - [ ] 在 `FusionReportScreen.kt` 以 `LazyColumn` 依序放置卡片 `概覽/交叉主題/風險/30天/90天`
    - [ ] 在 `概覽` 卡片：顯示一段 `overview` 摘要與「分享」IconButton
    - [ ] 在 `交叉主題` 卡片：以 `AssistChip` 列出 `crossThemes`，可水平捲動
    - [ ] 在 `風險` 卡片：以帶圖示的 `ListItem` 顯示 `risks`
    - [ ] 在 `30天行動` 卡片：以核取清單顯示 `actions30`，可勾選本地完成狀態
    - [ ] 在 `90天行動` 卡片：以核取清單顯示 `actions90`，可勾選本地完成狀態
    - [ ] 在 `FusionReportScreen.kt` 底部 `ExtendedFloatingActionButton` 文案「重新生成」
    - [ ] 在 `重新生成` 點擊時檢查權益，具備則排程 `FusionReportWorker`
    - [ ] 在 `:app/ui/screens/HomeScreen.kt` 新增入口卡片「綜合 AI 總結」導向最近 `reportId` 或顯示「生成一次」
    - [ ] 在 所有元件遵循 Material 3 間距與觸控區；不得加入 Debug-only 按鈕
  - [ ] 付費與 SKU 串接
    - [ ] 在 `:billing` 新增常數 `FUSION_DEEP_ONE = "fusion_deep_one"`
    - [ ] 在 `PurchaseScreen` 新增商品卡「綜合 AI 總結」
    - [ ] 在 `FusionReportScreen.kt` 若無權益則顯示解鎖條（單次購買或 VIP）
    - [ ] 在 解鎖條「立即購買」呼叫 `BillingManager.launchPurchase(FUSION_DEEP_ONE)`
    - [ ] 在 購買成功後自動啟動一次 `FusionReportWorker`
  - [ ] 效能與一致性測試
    - [ ] 在 模擬器 Pixel6Api35 測試生成 700~900 tokens 時間不超過既定閾值
    - [ ] 在 快速捲動 `FusionReportScreen` 驗證 60fps 以上（開啟 `Show layout bounds` 檢視 Overdraw）
    - [ ] 在 跨三次生成比較文案不重複過高（哈希相似度 < 0.9）
    - [ ] 在 斷網狀態點擊重新生成顯示錯誤提示且不崩潰
    - [ ] 在 權益切換（購買/退訂/VIP）對 UI 即時反應
- [ ] V8.0 塔羅運勢（年／月／日）+ AI
  - [ ] 資料與資產
    - [ ] 在 `:app/src/main/assets/tarot` 建立 `TarotDeck.json`
    - [ ] 在 `TarotDeck.json` 定義結構 `{"id":0,"name":"The Fool","upright":"...","reversed":"...","theme":"..."}` * 78 張
    - [ ] 在 `:core/tarot` 建立套件與 `TarotModels.kt` 定義 `data class Card(id:Int,name:String,upright:String,reversed:String,theme:String)`
    - [ ] 在 `:core/tarot` 建立 `TarotRepo.kt` 載入 `TarotDeck.json` 提供 `fun all():List<Card>`
  - [ ] 服務（種子抽牌）
    - [ ] 在 `:core/tarot` 建立 `TarotService.kt`
    - [ ] 在 `TarotService.kt` 實作 `fun draw(seed:Long, count:Int=1): List<Pair<Card,Boolean>>`（Boolean 表正逆位）
    - [ ] 在 `TarotService.kt` 實作 `fun fortune(scope:Scope, seed:Long): List<Pair<Card,Boolean>>`（scope=Year/Month/Day）
    - [ ] 在 `:core/tarot` 建立 `TarotPromptBuilder.kt` `fun buildFortune(cards, scope, locale):String`
    - [ ] 在 `:core/tarot` 建立單元測試 `TarotServiceDeterminismTest.kt` 驗證相同 seed 穩定輸出
  - [ ] 資料表與儲存
    - [ ] 在 `:data` 建立 `entity/TarotFortune.kt`（id,scope,date,cards,detail,updatedAt）
    - [ ] 在 `:data` 建立 `dao/TarotFortuneDao.kt` 含 `getByDate(scope,date)`, `upsert`
    - [ ] 在 `:data` 建立 `repository/TarotFortuneRepository.kt`
  - [ ] 路由與畫面
    - [ ] 在 `NavGraph.kt` 新增 `const val ROUTE_TAROT_FORTUNE = "tarot.fortune"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_TAROT_FORTUNE){ TarotFortuneScreen() }`
    - [ ] 在 `:app/ui/screens` 建立 `TarotFortuneScreen.kt`
    - [ ] 在 `TarotFortuneScreen.kt` 放置分段控制 `Year/Month/Day`
    - [ ] 在 `TarotFortuneScreen.kt` 顯示卡片縮圖（3~5 張）與重點 `theme`
    - [ ] 在 `TarotFortuneScreen.kt` 右下方主要按鈕「查看長文」
    - [ ] 在 `TarotFortuneScreen.kt` 點擊「查看長文」若無全文則以 `OnnxLlamaSession` 生成並寫入 DB
    - [ ] 在 `HomeScreen.kt` 新增入口卡片「塔羅運勢」導向 `ROUTE_TAROT_FORTUNE`
    - [ ] 在 畫面不加入 Developer-only 控制
  - [ ] 付費與解鎖
    - [ ] 在 `:billing` 新增常數 `TAROT_FORTUNE_ONE = "tarot_fortune_one"`
    - [ ] 在 `TarotFortuneScreen.kt` 非 VIP 顯示解鎖條：單次 `50 幣` 或 `購買 TAROT_FORTUNE_ONE`
    - [ ] 在 `TarotFortuneScreen.kt` 若選廣告方案需觀看 5 支 Rewarded 後解鎖一次
    - [ ] 在 `TarotFortuneScreen.kt` 解鎖後當日同 scope 可重看不重扣
  - [ ] 測試與素材
    - [ ] 在 測試以固定 seed 驗證抽牌重現性
    - [ ] 在 測試 UI 捲動與卡片載入效能
    - [ ] 在 測試 付費與廣告解鎖流程
    - [ ] 在 擷取 2 張畫面截圖（Year/Day）供上架
- [ ] V9.0 易經運勢（年／月／日）+ AI
  - [ ] 資料與資產
    - [ ] 在 `:app/src/main/assets/iching` 建立 `IChingData.json`
    - [ ] 在 `IChingData.json` 定義 `{"hex":1,"name":"乾為天","judgement":"...","image":"...","lines":["...","...","...","...","...","..."]}`
  - [ ] 服務（起卦與運勢）
    - [ ] 在 `:core/iching` 建立 `IChingModels.kt` 與 `data class Hexagram(...)`
    - [ ] 在 `:core/iching` 建立 `IChingRepo.kt` 讀取資料
    - [ ] 在 `:core/iching` 建立 `IChingFortuneService.kt` 實作 `fun cast(seed:Long): Hexagram` 與 `fun fortune(scope, seed): Hexagram`
    - [ ] 在 `:core/iching` 建立 `IChingPromptBuilder.kt` `fun buildFortune(hex, scope, locale):String`
  - [ ] 儲存與畫面
    - [ ] 在 `:data` 建立 `entity/IChingFortune.kt`（id,scope,date,hex,detail,updatedAt）
    - [ ] 在 `:data` 建立 `dao/IChingFortuneDao.kt` 與 `repository/IChingFortuneRepository.kt`
    - [ ] 在 `NavGraph.kt` 新增 `const val ROUTE_ICHING_FORTUNE = "iching.fortune"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_ICHING_FORTUNE){ IChingFortuneScreen() }`
    - [ ] 在 `:app/ui/screens` 建立 `IChingFortuneScreen.kt` 顯示卦象、卦名、重點、與「查看長文」
    - [ ] 在 `HomeScreen.kt` 新增入口卡片「易經運勢」導向 `ROUTE_ICHING_FORTUNE`
  - [ ] 付費與沿用樣式
    - [ ] 在 `IChingFortuneScreen.kt` 沿用 V8.0 解鎖條設計
    - [ ] 在 非 VIP 可 `50 幣` 或 `看 5 支廣告` 解鎖
  - [ ] 測試
    - [ ] 在 固定 seed 驗證卦象映射穩定
    - [ ] 在 UI 檢查文案排版與省略
    - [ ] 在 解鎖流程與儲存一致性驗證
- [ ] V10.0 流年／流月／流日（多體系趨勢）
  - [ ] 引擎與計分
    - [ ] 在 `:core/trend` 建立 `TrendModels.kt` 定義 `data class TrendPoint(date: LocalDate, score: Int, tags: List<String>)`
    - [ ] 在 `:core/trend` 建立 `TrendEngine.kt`
    - [ ] 在 `TrendEngine.kt` 實作 `fun aggregateDaily(input:FusionInput, date: LocalDate): TrendPoint`
    - [ ] 在 `TrendEngine.kt` 實作 `fun range(start: LocalDate, end: LocalDate, input:FusionInput): List<TrendPoint>`
    - [ ] 在 `TrendEngine.kt` 實作 平滑 `movingAverage(window=7)`
    - [ ] 在 `TrendEngine.kt` 實作 分解 `monthBuckets()` 與 `yearBuckets()`
  - [ ] 儲存與快取
    - [ ] 在 `:data` 建立 `entity/TrendCache.kt`（date, score, tags, updatedAt）
    - [ ] 在 `:data` 建立 `dao/TrendCacheDao.kt` 與 `repository/TrendRepository.kt`
  - [ ] UI/UX 與互動
    - [ ] 在 `NavGraph.kt` 新增 `const val ROUTE_TREND = "trend"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_TREND){ TrendScreen() }`
    - [ ] 在 `:app/ui/screens` 建立 `TrendScreen.kt`
    - [ ] 在 `TrendScreen.kt` 上方放置時間範圍分段控制 `Year/Month/Day`
    - [ ] 在 `TrendScreen.kt` 使用 `Canvas` 畫折線圖與標籤（純 Compose，不用付費圖表）
    - [ ] 在 `TrendScreen.kt` 提供手勢：水平拖曳捲動、雙指縮放
    - [ ] 在 `TrendScreen.kt` 提供日期範圍選擇器（開始/結束）
    - [ ] 在 `TrendScreen.kt` 點選節點顯示 Tooltip（date/score/tags）
  - [ ] 付費與門檻
    - [ ] 在 `TrendScreen.kt` 若 `isVIP=false` 只顯示最近 14 天
    - [ ] 在 `TrendScreen.kt` 若 `isVIP=true` 顯示 1 年與 5 年範圍
  - [ ] 效能與測試
    - [ ] 在 模擬器測試 365 個點繪製 60fps
    - [ ] 在 平滑與捲動過程不觸發 GC 抖動
    - [ ] 在 日期範圍切換資料來源正確
- [ ] V11.0 每日總和分析儀表板
  - [ ] 資料來源整合
    - [ ] 在 `:core/dashboard` 建立 `DailyDashboardAggregator.kt`
    - [ ] 在 `DailyDashboardAggregator.kt` 聚合來源：星盤重點、塔羅重點、易經重點、黃曆、流日分數
    - [ ] 在 `DailyDashboardAggregator.kt` 輸出 `data class DailyDashboard(date, highlights: List<Highlight>, score:Int)`
  - [ ] 路由與畫面
    - [ ] 在 `NavGraph.kt` 新增 `const val ROUTE_DASHBOARD_DAILY = "dashboard.daily"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_DASHBOARD_DAILY){ DailyDashboardScreen() }`
    - [ ] 在 `:app/ui/screens` 建立 `DailyDashboardScreen.kt`
    - [ ] 在 `DailyDashboardScreen.kt` 置頂顯示日期與總分環形指示
    - [ ] 在 `DailyDashboardScreen.kt` 以卡片列表顯示五大來源重點各 3 條
    - [ ] 在 `DailyDashboardScreen.kt` 提供「刷新」按鈕觸發重新聚合
  - [ ] 權益與解鎖
    - [ ] 在 `DailyDashboardScreen.kt` 若 `isVIP=true` 直接顯示
    - [ ] 在 `DailyDashboardScreen.kt` 若 `isVIP=false` 顯示「看廣告 5 次解鎖 1 天」
    - [ ] 在 看完 5 支 Rewarded 後當天解鎖僅記錄於本地
  - [ ] 測試與上架
    - [ ] 在 多來源資料不同步時仍能顯示已可得的重點
    - [ ] 在 權益控制正確與刷新不卡 UI
    - [ ] 在 擷取 1 張儀表板截圖並於商店新增「總和分析」
- [ ] V11.1 每月總和分析儀表板
  - [ ] 聚合與產出
    - [ ] 在 `:core/dashboard` 建立 `MonthlyDashboardAggregator.kt`
    - [ ] 在 `MonthlyDashboardAggregator.kt` 聚合該月每日 `DailyDashboard` 產出月度重點與趨勢
  - [ ] PDF 匯出（本機）
    - [ ] 在 `:app/export` 建立 `MonthlyPdfExporter.kt`
    - [ ] 在 `MonthlyPdfExporter.kt` 使用 `PdfDocument` 生成 2~3 頁 PDF（封面/重點/趨勢）
    - [ ] 在 `MonthlyPdfExporter.kt` 寫入 `/files/exports/monthly-YYYYMM.pdf`
  - [ ] 路由與畫面
    - [ ] 在 `NavGraph.kt` 新增 `const val ROUTE_DASHBOARD_MONTH = "dashboard.month"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_DASHBOARD_MONTH){ MonthlyDashboardScreen() }`
    - [ ] 在 `:app/ui/screens` 建立 `MonthlyDashboardScreen.kt` 顯示月度摘要與「匯出 PDF」按鈕
  - [ ] 付費與測試
    - [ ] 在 `MonthlyDashboardScreen.kt` 非 VIP 顯示「單次 50 幣」解鎖 PDF
    - [ ] 在 測試產生 PDF 可被分享與開啟
    - [ ] 在 測試 月度聚合與圖表效能
- [ ] V11.2 每年總和分析儀表板
  - [ ] 聚合與長文
    - [ ] 在 `:core/dashboard` 建立 `YearlyDashboardAggregator.kt`
    - [ ] 在 `YearlyDashboardAggregator.kt` 聚合 12 個 `MonthlyDashboard` 產出年度指標
    - [ ] 在 `:core/ai` 建立 `YearlyPromptBuilder.kt` `fun buildYearlyAdvice(metrics, locale): String`
    - [ ] 在 `:app/workers/YearlyAdviceWorker.kt` 以 `OnnxLlamaSession` 生成年度長文並寫入 DB
  - [ ] 路由與畫面
    - [ ] 在 `NavGraph.kt` 新增 `const val ROUTE_DASHBOARD_YEAR = "dashboard.year"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_DASHBOARD_YEAR){ YearlyDashboardScreen() }`
    - [ ] 在 `:app/ui/screens` 建立 `YearlyDashboardScreen.kt` 顯示年度關鍵圖表與長文
  - [ ] 付費與測試
    - [ ] 在 `YearlyDashboardScreen.kt` 非 VIP 顯示「80 幣單次」解鎖長文
    - [ ] 在 測試 年度計算效能與長文長度不超出渲染限制
- [ ] V12.0 塔羅占卜 + AI 解牌
  - [ ] 專案與依賴準備
    - [ ] 在 `:core/tarot` 建立套件結構 `com.aidestinymaster.core.tarot`
    - [ ] 在 `:app/src/main/assets/tarot` 確認 `TarotDeck.json` 已存在（78 張，沿用 V8.0），若無則建立空檔待填
    - [ ] 在 `:core/tarot/build.gradle.kts` 確認已加入 `kotlinx-serialization-json` 依賴（沿用共用版本）
  - [ ] 資料結構與資料層
    - [ ] 在 `:data/src/main/java/.../entity` 建立 `TarotReading.kt`
    - [ ] 在 `TarotReading.kt` 定義 `data class TarotReading(id:String, spreadType:String, seed:Long, question:String?, cards:List<Int>, reversed:List<Boolean>, positions:List<String>, summary:String?, detailEnc:String?, createdAt:Instant, updatedAt:Instant, unlocked:Boolean, paidBy:String?)`
    - [ ] 在 `:data/src/main/java/.../dao` 建立 `TarotReadingDao.kt`
    - [ ] 在 `TarotReadingDao.kt` 定義 `@Insert(onConflict=REPLACE) suspend fun upsert(reading:TarotReading)`
    - [ ] 在 `TarotReadingDao.kt` 定義 `@Query("SELECT * FROM TarotReading WHERE id=:id") suspend fun get(id:String):TarotReading?`
    - [ ] 在 `TarotReadingDao.kt` 定義 `@Query("SELECT * FROM TarotReading ORDER BY createdAt DESC LIMIT :limit") suspend fun listRecent(limit:Int):List<TarotReading>`
    - [ ] 在 `:data/src/main/java/.../repo` 建立 `TarotReadingRepository.kt`
    - [ ] 在 `TarotReadingRepository.kt` 封裝 `upsert/get/listRecent` 並處理 `detailEnc` 加解密（呼叫 Security Crypto AES-GCM）
    - [ ] 在 `:data/src/main/java/.../AppDatabase.kt` 新增 `abstract fun tarotReadingDao(): TarotReadingDao`
    - [ ] 在 `:data/src/main/java/.../db/migrations` 建立 `Migration_vX_to_vXplus1_TarotReading.kt`（補上新表），並在 `Room.databaseBuilder` 註冊
  - [ ] 服務層：牌陣與抽牌
    - [ ] 在 `:core/tarot` 建立 `TarotDeckRepo.kt` 載入 `TarotDeck.json` 提供 `fun card(id:Int):Card` 與 `fun all():List<Card>`
    - [ ] 在 `:core/tarot` 建立 `TarotSpreadService.kt`
    - [ ] 在 `TarotSpreadService.kt` 定義 `enum class SpreadType { ONE, THREE, CELTIC_CROSS }`
    - [ ] 在 `TarotSpreadService.kt` 定義 `data class DrawResult(val cards:List<Int>, val reversed:List<Boolean>, val positions:List<String>)`
    - [ ] 在 `TarotSpreadService.kt` 實作 `fun draw(spread:SpreadType, seed:Long): DrawResult`（使用 `Random(seed)` 決定抽牌序與正逆位）
    - [ ] 在 `TarotSpreadService.kt` 為 `ONE` 產生 `positions=["Focus"]`
    - [ ] 在 `TarotSpreadService.kt` 為 `THREE` 產生 `positions=["Past","Present","Future"]`
    - [ ] 在 `TarotSpreadService.kt` 為 `CELTIC_CROSS` 產生 10 位置名稱（Cross/Above/Below/Recent/Near/F1~F4）
    - [ ] 在 `:core/tarot` 建立 `TarotShareBuilder.kt` 實作 `fun buildShare(reading:TarotReading, deck:TarotDeckRepo): String`（去個資、含牌名/位置/摘要）
  - [ ] AI Prompt 與生成流程
    - [ ] 在 `:core/ai` 建立 `TarotPromptBuilder.kt`
    - [ ] 在 `TarotPromptBuilder.kt` 實作 `fun buildReading(deck:TarotDeckRepo, reading:TarotReading, locale:Locale): String`（包含：使用者問題、每張牌名+正逆位+位置含義）
    - [ ] 在 `:app/src/main/java/.../workers` 建立 `TarotReadingWorker.kt`
    - [ ] 在 `TarotReadingWorker.kt` 讀取 `TarotReading` 與 `TarotDeckRepo` → 呼叫 `TarotPromptBuilder.buildReading`
    - [ ] 在 `TarotReadingWorker.kt` 呼叫 `OnnxLlamaSession.generate(prompt)` 收集流式輸出為 `detail`
    - [ ] 在 `TarotReadingWorker.kt` 將 `detail` 以 AES-GCM 加密寫回 `TarotReading.detailEnc` 並更新 `summary`（取前 140 字）
    - [ ] 在 `TarotReadingWorker.kt` 發送完成通知；點擊導向 `tarot.reading.result/{id}`
  - [ ] 路由與畫面：占卜流程
    - [ ] 在 `:app/ui/navigation/NavGraph.kt` 新增 `const val ROUTE_TAROT_READING_START = "tarot.reading.start"`
    - [ ] 在 `NavGraph.kt` 新增 `const val ROUTE_TAROT_READING_RESULT = "tarot.reading.result/{id}"`
    - [ ] 在 `NavGraph.kt` 新增 `const val ROUTE_TAROT_READING_HISTORY = "tarot.reading.history"`
    - [ ] 在 `NavGraph.kt` 新增對應 `composable` 三條路由
    - [ ] 在 `:app/ui/screens/tarot` 建立 `TarotReadingStartScreen.kt`
    - [ ] 在 `TarotReadingStartScreen.kt` 放置分段控制 `ONE/THREE/CELTIC_CROSS`
    - [ ] 在 `TarotReadingStartScreen.kt` 放置輸入框「問題（選填）」限制 120 字
    - [ ] 在 `TarotReadingStartScreen.kt` 放置「隨機種子」Switch（關閉時顯示數字輸入以重現讀數）
    - [ ] 在 `TarotReadingStartScreen.kt` 放置主要按鈕「抽牌」
    - [ ] 在 `TarotReadingStartScreen.kt` 按下「抽牌」呼叫 `TarotSpreadService.draw` 生成 `DrawResult` 並建立 `TarotReading` 寫入 DB，導向結果頁
    - [ ] 在 `:app/ui/screens/tarot` 建立 `TarotReadingResultScreen.kt`
    - [ ] 在 `TarotReadingResultScreen.kt` 以格狀排版顯示牌面縮圖與位置名稱；正逆位以旋轉或標籤顯示
    - [ ] 在 `TarotReadingResultScreen.kt` 顯示摘要區塊（初始為「尚未生成 AI 解牌」）
    - [ ] 在 `TarotReadingResultScreen.kt` 底部放置主要按鈕「生成 AI 解牌（背景）」與次要按鈕「分享」
    - [ ] 在 `TarotReadingResultScreen.kt` 點擊「生成 AI 解牌」→ 權益檢查 → 排程 `TarotReadingWorker`
    - [ ] 在 `TarotReadingResultScreen.kt` 監聽 Worker 狀態；完成後展開長文（解鎖規則見付費）
    - [ ] 在 `:app/ui/screens/tarot` 建立 `TarotReadingHistoryScreen.kt` 顯示最近讀數列表（日期/牌陣/摘要）
    - [ ] 在 `HomeScreen.kt` 新增入口卡片「塔羅占卜」導向 `ROUTE_TAROT_READING_START`
  - [ ] 付費解鎖與 Coins
    - [ ] 在 `:billing` 新增常數 `TAROT_READING_ONE = "tarot_reading_one"`
    - [ ] 在 `TarotReadingResultScreen.kt` 若 `isVIP=true` 直接顯示長文
    - [ ] 在 `TarotReadingResultScreen.kt` 若 `isVIP=false` 且未解鎖顯示解鎖條（按鈕「用 50 幣解鎖」「單次購買」）
    - [ ] 在 點擊「用 50 幣解鎖」呼叫 `CoinsService.spend(50)` 成功則將 `reading.unlocked=true` 並刷新 UI
    - [ ] 在 點擊「單次購買」呼叫 `BillingManager.launchPurchase(TAROT_READING_ONE)` 成功後 `unlocked=true`
    - [ ] 在 解鎖後生成或查看長文不再重扣
  - [ ] 分享與本地儲存
    - [ ] 在 `TarotReadingResultScreen.kt` 點擊「分享」呼叫 `TarotShareBuilder.buildShare` 產出文字
    - [ ] 在 分享 Intent 僅包含牌名/位置/摘要，排除問題內容（除非使用者勾選同意）
    - [ ] 在 `TarotReadingRepository` 寫入 `updatedAt` 供歷史排序
  - [ ] 測試與驗證
    - [ ] 在 單元測試 `TarotSpreadServiceTest.kt` 驗證相同 `seed`/`spread` 產出相同結果
    - [ ] 在 單元測試 `TarotPromptBuilderTest.kt` 驗證模板包含所有位置與牌名
    - [ ] 在 單元測試 `TarotReadingWorkerTest.kt` 模擬輸出並驗證加密寫回
    - [ ] 在 UI 測試流程：抽牌→未解鎖顯示付費條→用幣解鎖→生成→分享
    - [ ] 在 效能檢查：結果頁快速捲動 60fps，長文渲染不卡頓
    - [ ] 在 合規檢查：畫面無 Debug-only 控制與隱藏入口
- [ ] V13.0 易經占卜 + AI 解卦
  - [ ] 資料結構與資料層
    - [ ] 在 `:data/entity` 建立 `IChingReading.kt`
    - [ ] 在 `IChingReading.kt` 定義 `data class IChingReading(id:String, method:String, seed:Long?, castAt:Instant?, primaryHex:Int, changingLines:List<Int>, resultHex:Int?, question:String?, summary:String?, detailEnc:String?, createdAt:Instant, unlocked:Boolean, paidBy:String?)`
    - [ ] 在 `:data/dao` 建立 `IChingReadingDao.kt`（`upsert/get/listRecent`）
    - [ ] 在 `:data/repo` 建立 `IChingReadingRepository.kt`（含 AES-GCM 加解密）
    - [ ] 在 `AppDatabase` 新增 `abstract fun iChingReadingDao(): IChingReadingDao` 與對應 Migration
  - [ ] 服務層：搖卦／時間起卦
    - [ ] 在 `:core/iching` 建立 `IChingDivinationService.kt`
    - [ ] 在 `IChingDivinationService.kt` 實作 `fun castByCoins(seed:Long): Pair<Int, List<Int>>`（三錢法六次，回傳主卦與動爻）
    - [ ] 在 `IChingDivinationService.kt` 實作 `fun castByTime(time:Instant): Pair<Int, List<Int>>`（以時間映射上/下卦與動爻）
    - [ ] 在 `IChingDivinationService.kt` 實作 `fun applyChanging(primary:Int, changing:List<Int>): Int`（得之卦）
    - [ ] 在 `:core/iching` 建立 `IChingShareBuilder.kt` 產出分享文本（卦名/動爻/要旨）
  - [ ] AI Prompt 與生成流程
    - [ ] 在 `:core/ai` 建立 `IChingPromptBuilder.kt` 實作 `fun buildReading(primary:Int, result:Int?, changing:List<Int>, question:String?, locale:Locale): String`
    - [ ] 在 `:app/workers` 建立 `IChingReadingWorker.kt`，流程：讀取 Reading → 建 Prompt → `OnnxLlamaSession.generate` → 加密寫回
    - [ ] 在 完成時發送通知導向 `iching.reading.result/{id}`
  - [ ] 路由與畫面
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_ICHING_READING_START = "iching.reading.start"`
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_ICHING_READING_RESULT = "iching.reading.result/{id}"`
    - [ ] 在 `:app/ui/screens/iching` 建立 `IChingReadingStartScreen.kt`
    - [ ] 在 `IChingReadingStartScreen.kt` 放置分段控制「搖卦」「時間起卦」
    - [ ] 在 「搖卦」模式加入 6 次按鈕「擲幣」與視覺化六爻累積
    - [ ] 在 「時間起卦」模式顯示當前時間與主要按鈕「起卦」
    - [ ] 在 兩模式皆提供「問題（選填）」輸入框與「抽籤」主要按鈕建立 `IChingReading` 並導向結果頁
    - [ ] 在 `:app/ui/screens/iching` 建立 `IChingReadingResultScreen.kt` 顯示主卦/動爻/之卦與重點
    - [ ] 在 結果頁提供「生成 AI 解卦（背景）」「分享」按鈕
  - [ ] 付費解鎖與 Coins（沿用 V12.0）
    - [ ] 在 `:billing` 繼續沿用 `TAROT_READING_ONE` 以外，新增常數 `ICHING_READING_ONE = "iching_reading_one"`（如需區分）
    - [ ] 在 結果頁非 VIP 顯示解鎖條：50 幣或單次購買 `ICHING_READING_ONE`
    - [ ] 在 解鎖成功後允許生成/查看長文
  - [ ] 測試與驗證
    - [ ] 在 單元測試 `IChingDivinationServiceTest.kt` 驗證搖卦 determinism（固定 seed）
    - [ ] 在 單元測試 `IChingPromptBuilderTest.kt` 驗證模板包含卦名與動爻
    - [ ] 在 UI 測試流程：搖卦→結果→解鎖→生成→分享
    - [ ] 在 效能檢查：結果頁渲染與滾動流暢，無 Debug-only 控制
- [ ] V14.0 梅花易（主動數字）+ AI
  - [ ] 資料結構與資料層
    - [ ] 在 `:data/entity` 建立 `MeihuaNumberReading.kt`
    - [ ] 在 `MeihuaNumberReading.kt` 定義 `data class MeihuaNumberReading(id:String, number:String, time:Instant, primaryHex:Int, resultHex:Int?, summary:String?, detailEnc:String?, createdAt:Instant, unlocked:Boolean, paidBy:String?)`
    - [ ] 在 `:data/dao` 建立 `MeihuaNumberReadingDao.kt` 與對應 Repo 與 Migration
  - [ ] 服務層：數字轉卦
    - [ ] 在 `:core/iching` 建立 `MeihuaNumberService.kt`
    - [ ] 在 `MeihuaNumberService.kt` 實作 `fun toHex(number:String, time:Instant): Pair<Int, Int?>`（以數字拆分上/下卦與可選動爻）
    - [ ] 在 `:core/ai` 建立 `MeihuaPromptBuilder.kt` `fun build(number:String, primary:Int, result:Int?, locale:Locale): String`
  - [ ] 路由與畫面
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_MEIHUA_NUMBER = "meihua.number"`
    - [ ] 在 `:app/ui/screens/meihua` 建立 `MeihuaNumberScreen.kt`
    - [ ] 在 `MeihuaNumberScreen.kt` 放置輸入框「主動數字」與日期時間選擇器
    - [ ] 在 `MeihuaNumberScreen.kt` 主要按鈕「起卦」→ 生成 Reading → 顯示主卦與（如有）之卦
    - [ ] 在 `MeihuaNumberScreen.kt` 提供「生成 AI 解讀（背景）」與「分享」
  - [ ] 付費與測試（沿用 V12.0）
    - [ ] 在 非 VIP 顯示解鎖條（50 幣或單次 `meihua_reading_one`，若使用共用 SKU 則沿用）
    - [ ] 在 單元測試 `MeihuaNumberServiceTest.kt` 驗證特定數字輸出一致
    - [ ] 在 UI 測試流程：輸入→起卦→解鎖→生成→分享
- [ ] V14.1 梅花易（事件取卦）+ AI
  - [ ] 資料結構與資料層
    - [ ] 在 `:data/entity` 建立 `MeihuaEventReading.kt`
    - [ ] 在 `MeihuaEventReading.kt` 定義 `data class MeihuaEventReading(id:String, title:String, location:String?, time:Instant, primaryHex:Int, resultHex:Int?, summary:String?, detailEnc:String?, createdAt:Instant, unlocked:Boolean, paidBy:String?)`
    - [ ] 在 `:data/dao` 建立 `MeihuaEventReadingDao.kt` 與 Repo 與 Migration
  - [ ] 服務層：事件取卦
    - [ ] 在 `:core/iching` 建立 `MeihuaEventService.kt`
    - [ ] 在 `MeihuaEventService.kt` 實作 `fun toHex(title:String, time:Instant, location:String?): Pair<Int, Int?>`（以時間/標題長度/方位字元映射上/下卦與動爻）
    - [ ] 在 `:core/ai` 建立 `MeihuaEventPromptBuilder.kt` `fun build(title:String, primary:Int, result:Int?, locale:Locale): String`
  - [ ] 路由與畫面
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_MEIHUA_EVENT = "meihua.event"`
    - [ ] 在 `:app/ui/screens/meihua` 建立 `MeihuaEventScreen.kt`
    - [ ] 在 `MeihuaEventScreen.kt` 放置輸入框「事件標題」與可選地點、時間挑選器
    - [ ] 在 `MeihuaEventScreen.kt` 主要按鈕「起卦」→ 顯示卦象 → 提供「生成 AI 解讀（背景）」與「分享」
  - [ ] 付費與測試（沿用 V12.0）
    - [ ] 在 非 VIP 顯示解鎖條（50 幣或單次 `meihua_reading_one`）
    - [ ] 在 單元測試 `MeihuaEventServiceTest.kt` 驗證輸出 determinism（給定同輸入）
    - [ ] 在 UI 測試：輸入→起卦→解鎖→生成→分享
- [ ] V15.0 京房易占
  - [ ] 資料結構與資料層
    - [ ] 在 `:data/entity` 建立 `JingFangReading.kt`
    - [ ] 在 `JingFangReading.kt` 定義 `data class JingFangReading(id:String, time:Instant, method:String, primaryHex:Int, palace:String, relation:String, resultHex:Int?, summary:String?, detailEnc:String?, createdAt:Instant, unlocked:Boolean, paidBy:String?)`
    - [ ] 在 `:data/dao` 建立 `JingFangReadingDao.kt` 與 Repo 與 Migration
  - [ ] 服務層：演算法與詞庫
    - [ ] 在 `:core/iching` 建立 `JingFangService.kt`
    - [ ] 在 `JingFangService.kt` 實作 `fun compute(time:Instant): Triple<Int,String,String>`（回傳主卦、用神宮位、六親關係）
    - [ ] 在 `JingFangService.kt` 實作 `fun deriveResult(primary:Int, factor:String): Int?`（簡化之卦推導）
    - [ ] 在 `:core/iching` 建立 `JingFangGlossary.json`（自撰詞條：宮位/六親/要旨）
    - [ ] 在 `:core/iching` 建立 `JingFangGlossary.kt` 提供 `fun meaning(palace:String, relation:String): String`
  - [ ] AI 與生成流程
    - [ ] 在 `:core/ai` 建立 `JingFangPromptBuilder.kt` `fun build(primary:Int, palace:String, relation:String, result:Int?, locale:Locale): String`
    - [ ] 在 `:app/workers` 建立 `JingFangReadingWorker.kt`（模板→生成→加密→寫回）
  - [ ] 路由與畫面
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_JINGFANG = "jingfang"`
    - [ ] 在 `:app/ui/screens/jingfang` 建立 `JingFangScreen.kt`
    - [ ] 在 `JingFangScreen.kt` 顯示時間挑選器與主要按鈕「起卦」，呈現主卦/宮位/六親
    - [ ] 在 `JingFangScreen.kt` 提供「生成 AI 解讀（背景）」與「分享」
  - [ ] 付費與測試（沿用 V12.0）
    - [ ] 在 非 VIP 顯示解鎖條（50 幣或單次 `jingfang_reading_one`）
    - [ ] 在 單元測試 `JingFangServiceTest.kt` 驗證輸出穩定與欄位合法
    - [ ] 在 UI 測試：起卦→解鎖→生成→分享
- [ ] V16.0 合盤（星盤）AI 報告
  - [ ] 專案與套件骨架
    - [ ] 在 `:core/astro` 建立套件 `core.astro.synastry`
    - [ ] 在 `:core/ai` 建立套件 `core.ai.synastry`
    - [ ] 在 `:app/ui/screens` 建立套件 `ui/screens/synastry`
    - [ ] 在 `:data/entity` 建立檔案夾 `synastry`
    - [ ] 在 `:data/dao` 建立檔案夾 `synastry`
    - [ ] 在 `:data/repository` 建立檔案夾 `synastry`
  - [ ] 資料結構
    - [ ] 在 `:data/entity/synastry` 建立 `SynastryPair.kt`
    - [ ] 在 `SynastryPair.kt` 定義 `data class SynastryPair(val id:String,val aChartId:String,val bChartId:String,val createdAt:Instant)`
    - [ ] 在 `:data/entity/synastry` 建立 `SynastryAspect.kt`
    - [ ] 在 `SynastryAspect.kt` 定義 `data class SynastryAspect(val type:String,val orb:Double,val planetA:String,val planetB:String,val houseOverlay:String?)`
    - [ ] 在 `:data/entity/synastry` 建立 `SynastryReport.kt`
    - [ ] 在 `SynastryReport.kt` 定義 `data class SynastryReport(val id:String,val pairId:String,val overview:String?,val strengths:List<String>?,val challenges:List<String>?,val advice30:List<String>?,val advice90:List<String>?,val rawPromptHash:String,val tokens:Int,val createdAt:Instant,val unlocked:Boolean,val paidBy:String?)`
    - [ ] 在 `:data/dao/synastry` 建立 `SynastryPairDao.kt`
    - [ ] 在 `SynastryPairDao.kt` 定義 `upsert(pair:SynastryPair)`
    - [ ] 在 `SynastryPairDao.kt` 定義 `getById(id:String):SynastryPair?`
    - [ ] 在 `SynastryPairDao.kt` 定義 `listRecent(limit:Int):List<SynastryPair>`
    - [ ] 在 `:data/dao/synastry` 建立 `SynastryReportDao.kt`
    - [ ] 在 `SynastryReportDao.kt` 定義 `upsert(report:SynastryReport)`
    - [ ] 在 `SynastryReportDao.kt` 定義 `getById(id:String):SynastryReport?`
    - [ ] 在 `SynastryReportDao.kt` 定義 `listByPair(pairId:String,limit:Int):List<SynastryReport>`
    - [ ] 在 `:data/AppDatabase` 新增 `abstract fun synastryPairDao(): SynastryPairDao`
    - [ ] 在 `:data/AppDatabase` 新增 `abstract fun synastryReportDao(): SynastryReportDao`
    - [ ] 在 `:data/db/migrations` 建立對應 Migration 檔
    - [ ] 在 `:data/repository/synastry` 建立 `SynastryRepository.kt`
    - [ ] 在 `SynastryRepository.kt` 實作 `createPair(aChartId:String,bChartId:String):String`
    - [ ] 在 `SynastryRepository.kt` 實作 `saveReport(report:SynastryReport)`
    - [ ] 在 `SynastryRepository.kt` 實作 `recentPairs(limit:Int)`
    - [ ] 在 `SynastryRepository.kt` 實作 `reportsForPair(pairId:String,limit:Int)`
  - [ ] 設計參數
    - [ ] 在 `:core/astro/synastry` 建立 `SynastryConfig.kt`
    - [ ] 在 `SynastryConfig.kt` 定義 `object SynastryConfig`
    - [ ] 在 `SynastryConfig.kt` 定義 `val supportedAspects = listOf(Conjunction,Opposition,Trine,Square,Sextile)`
    - [ ] 在 `SynastryConfig.kt` 定義 `val defaultOrbs = mapOf("Sun" to 8.0,"Moon" to 8.0,"Other" to 6.0)`
  - [ ] 相位計算引擎
    - [ ] 在 `:core/astro/synastry` 建立 `SynastryEngine.kt`
    - [ ] 在 `SynastryEngine.kt` 定義 `data class BodyPos(val name:String,val lon:Double)`
    - [ ] 在 `SynastryEngine.kt` 定義 `fun aspectAngle(type:String):Double`
    - [ ] 在 `SynastryEngine.kt` 定義 `fun orbFor(planetA:String,planetB:String):Double`
    - [ ] 在 `SynastryEngine.kt` 定義 `fun detectAspects(a:List<BodyPos>,b:List<BodyPos>):List<SynastryAspect>`
    - [ ] 在 `SynastryEngine.kt` 實作 `detectAspects` 計算角距離與容許度
    - [ ] 在 `SynastryEngine.kt` 定義 `fun houseOverlay(aHouses:List<House>,bBodies:List<BodyPos>):List<Pair<String,String>>`
    - [ ] 在 `SynastryEngine.kt` 實作 `houseOverlay` 輸出覆蓋描述
    - [ ] 在 `SynastryEngine.kt` 定義 `fun compute(a:NatalChart,b:NatalChart):Pair<List<SynastryAspect>,List<Pair<String,String>>>`
    - [ ] 在 `SynastryEngine.kt` 實作 `compute` 整合相位與覆蓋
    - [ ] 在 `:core/astro/synastry` 建立 `SynastryFormatter.kt`
    - [ ] 在 `SynastryFormatter.kt` 實作 `fun summarize(aspects:List<SynastryAspect>):Triple<String,List<String>,List<String>>`
  - [ ] AI Prompt 建構
    - [ ] 在 `:core/ai/synastry` 建立 `SynastryPromptBuilder.kt`
    - [ ] 在 `SynastryPromptBuilder.kt` 定義 `fun build(aName:String,bName:String,summary:String,strengths:List<String>,challenges:List<String>,overlays:List<Pair<String,String>>,locale:Locale):String`
    - [ ] 在 `SynastryPromptBuilder.kt` 插入段落標頭 `概覽`
    - [ ] 在 `SynastryPromptBuilder.kt` 插入段落標頭 `優勢`
    - [ ] 在 `SynastryPromptBuilder.kt` 插入段落標頭 `挑戰`
    - [ ] 在 `SynastryPromptBuilder.kt` 插入段落標頭 `30天行動`
    - [ ] 在 `SynastryPromptBuilder.kt` 插入段落標頭 `90天行動`
  - [ ] 背景任務
    - [ ] 在 `:app/workers` 建立 `SynastryReportWorker.kt`
    - [ ] 在 `SynastryReportWorker.kt` 讀取 `pairId` 與人名
    - [ ] 在 `SynastryReportWorker.kt` 讀取兩份 `NatalChart`
    - [ ] 在 `SynastryReportWorker.kt` 呼叫 `SynastryEngine.compute`
    - [ ] 在 `SynastryReportWorker.kt` 呼叫 `SynastryFormatter.summarize`
    - [ ] 在 `SynastryReportWorker.kt` 呼叫 `SynastryPromptBuilder.build`
    - [ ] 在 `SynastryReportWorker.kt` 呼叫 `OnnxLlamaSession.generate`
    - [ ] 在 `SynastryReportWorker.kt` 解析段落為 `overview/strengths/challenges/advice30/advice90`
    - [ ] 在 `SynastryReportWorker.kt` 寫入 `SynastryReportRepository.saveReport`
    - [ ] 在 `SynastryReportWorker.kt` 發送通知導向 `synastry.report/{reportId}`
  - [ ] 路由與畫面（挑選 → 檢視）
    - [ ] 在 `:app/ui/navigation/NavGraph.kt` 新增常數 `ROUTE_SYNASTRY_PICK = "synastry.pick"`
    - [ ] 在 `:app/ui/navigation/NavGraph.kt` 新增常數 `ROUTE_SYNASTRY_REPORT = "synastry.report/{reportId}"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_SYNASTRY_PICK){ SynastryPickScreen() }`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_SYNASTRY_REPORT){ backStack -> SynastryReportScreen(backStack.arguments?.getString("reportId")!!) }`
    - [ ] 在 `:app/ui/screens/synastry` 建立 `SynastryPickScreen.kt`
    - [ ] 在 `SynastryPickScreen.kt` 放置 `TopAppBar` 顯示標題「星盤合盤」
    - [ ] 在 `SynastryPickScreen.kt` 放置下拉選單一個供 `Person A` 選擇
    - [ ] 在 `SynastryPickScreen.kt` 放置下拉選單一個供 `Person B` 選擇
    - [ ] 在 `SynastryPickScreen.kt` 放置 `IconButton` 一個執行 A/B 互換
    - [ ] 在 `SynastryPickScreen.kt` 放置主要按鈕「生成合盤報告」
    - [ ] 在 `SynastryPickScreen.kt` 於按鈕點擊建立 `SynastryPair` 並寫入 DB
    - [ ] 在 `SynastryPickScreen.kt` 於按鈕點擊進行權益檢查
    - [ ] 在 `SynastryPickScreen.kt` 於權益通過後排程 `SynastryReportWorker`
    - [ ] 在 `SynastryPickScreen.kt` 於排程成功後導向 `SynastryReportScreen`
    - [ ] 在 `:app/ui/screens/synastry` 建立 `SynastryReportScreen.kt`
    - [ ] 在 `SynastryReportScreen.kt` 顯示卡片一張顯示 `概覽`
    - [ ] 在 `SynastryReportScreen.kt` 顯示卡片一張顯示 `優勢` 清單
    - [ ] 在 `SynastryReportScreen.kt` 顯示卡片一張顯示 `挑戰` 清單
    - [ ] 在 `SynastryReportScreen.kt` 顯示卡片一張顯示 `30天行動`
    - [ ] 在 `SynastryReportScreen.kt` 顯示卡片一張顯示 `90天行動`
    - [ ] 在 `SynastryReportScreen.kt` 放置 `ExtendedFAB` 一個文案「重新生成」
    - [ ] 在 `SynastryReportScreen.kt` 於 FAB 點擊再檢查權益並重排程 Worker
  - [ ] 付費 SKU 與配套
    - [ ] 在 `:billing` 新增常數 `SYNASTRY_DEEP_ONE = "synastry_deep_one"`
    - [ ] 在 `:billing` 新增常數 `SYNASTRY_BUNDLE_5 = "synastry_bundle_5"`
    - [ ] 在 `:data/entity` 建立 `CreditBucket.kt`
    - [ ] 在 `CreditBucket.kt` 定義 `data class CreditBucket(val sku:String,val remaining:Int,val updatedAt:Instant)`
    - [ ] 在 `:data/dao` 建立 `CreditBucketDao.kt`
    - [ ] 在 `CreditBucketDao.kt` 定義 `getBySku(sku:String):CreditBucket?`
    - [ ] 在 `CreditBucketDao.kt` 定義 `upsert(bucket:CreditBucket)`
    - [ ] 在 `:data/repository` 建立 `CreditStore.kt`
    - [ ] 在 `CreditStore.kt` 實作 `fun consumeOnce(sku:String):Boolean`
    - [ ] 在 `CreditStore.kt` 實作 `fun grantBundle(sku:String,count:Int)`
    - [ ] 在 `BillingManager` 的 `onPurchasesUpdated` 新增處理 `SYNASTRY_DEEP_ONE`
    - [ ] 在 `BillingManager` 的 `onPurchasesUpdated` 新增處理 `SYNASTRY_BUNDLE_5`
    - [ ] 在 `BillingManager` 處理單次購買時將 `CreditStore.grantBundle(SYNASTRY_DEEP_ONE,1)`
    - [ ] 在 `BillingManager` 處理套裝購買時將 `CreditStore.grantBundle(SYNASTRY_BUNDLE_5,5)`
    - [ ] 在 `SynastryPickScreen.kt` 權益檢查時先檢查 `isVIP`
    - [ ] 在 `SynastryPickScreen.kt` 權益檢查時若非 VIP 檢查 `CreditStore.consumeOnce` 兩 SKU 任一
    - [ ] 在 `SynastryPickScreen.kt` 權益不足時顯示解鎖條與「購買單次」按鈕
    - [ ] 在 `SynastryPickScreen.kt` 權益不足時顯示「購買 5 次套裝」按鈕
    - [ ] 在 `SynastryPickScreen.kt` 「購買單次」按鈕呼叫 `BillingManager.launchPurchase(SYNASTRY_DEEP_ONE)`
    - [ ] 在 `SynastryPickScreen.kt` 「購買 5 次套裝」按鈕呼叫 `BillingManager.launchPurchase(SYNASTRY_BUNDLE_5)`
  - [ ] 測試與效能
    - [ ] 在 `:core/astro/synastry` 建立 `SynastryEngineTest.kt`
    - [ ] 在 `SynastryEngineTest.kt` 測試相位角度計算正確
    - [ ] 在 `SynastryEngineTest.kt` 測試容許度判斷正確
    - [ ] 在 `SynastryEngineTest.kt` 測試覆蓋落宮輸出不為空
    - [ ] 在 `:core/ai/synastry` 建立 `SynastryPromptBuilderTest.kt`
    - [ ] 在 `SynastryPromptBuilderTest.kt` 驗證五個段落標頭存在
    - [ ] 在 `:app/ui/screens/synastry` 建立 `SynastryUiTest.kt`
    - [ ] 在 `SynastryUiTest.kt` 測試選單選擇與交換互動
    - [ ] 在 `SynastryUiTest.kt` 測試權益不足時顯示解鎖條
    - [ ] 在 `SynastryUiTest.kt` 測試長文頁面捲動流暢不掉幀
- [ ] V16.1 合盤（紫微）AI 報告
  - [ ] 服務與演算法
    - [ ] 在 `:core/ziwei` 建立 `ZiweiSynastry.kt`
    - [ ] 在 `ZiweiSynastry.kt` 定義 `data class ZiweiPairScore(val palace:String,val score:Int,val rationale:String)`
    - [ ] 在 `ZiweiSynastry.kt` 定義 `fun compare(a:ZiweiChart,b:ZiweiChart):List<ZiweiPairScore>`
    - [ ] 在 `ZiweiSynastry.kt` 實作以宮位對位與主星同氣加分
    - [ ] 在 `ZiweiSynastry.kt` 實作以四化衝突減分
  - [ ] AI 模板
    - [ ] 在 `:core/ai` 建立 `ZiweiSynastryPromptBuilder.kt`
    - [ ] 在 `ZiweiSynastryPromptBuilder.kt` 定義 `fun build(scores:List<ZiweiPairScore>,locale:Locale):String`
    - [ ] 在 `ZiweiSynastryPromptBuilder.kt` 插入段落 `緣份基調`
    - [ ] 在 `ZiweiSynastryPromptBuilder.kt` 插入段落 `宮位呼應`
    - [ ] 在 `ZiweiSynastryPromptBuilder.kt` 插入段落 `風險提醒`
  - [ ] 背景任務
    - [ ] 在 `:app/workers` 建立 `ZiweiSynastryWorker.kt`
    - [ ] 在 `ZiweiSynastryWorker.kt` 讀取兩份 `ZiweiChart`
    - [ ] 在 `ZiweiSynastryWorker.kt` 呼叫 `ZiweiSynastry.compare`
    - [ ] 在 `ZiweiSynastryWorker.kt` 呼叫 `ZiweiSynastryPromptBuilder.build`
    - [ ] 在 `ZiweiSynastryWorker.kt` 呼叫 `OnnxLlamaSession.generate` 並寫入 `SynastryReport`
  - [ ] UI 與路由
    - [ ] 在 `NavGraph.kt` 新增常數 `ROUTE_ZIWEI_SYNASTRY_PICK = "ziwei.synastry.pick"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_ZIWEI_SYNASTRY_PICK){ ZiweiSynastryPickScreen() }`
    - [ ] 在 `:app/ui/screens/synastry` 建立 `ZiweiSynastryPickScreen.kt`
    - [ ] 在 `ZiweiSynastryPickScreen.kt` 放置 A/B Chart 選擇控制
    - [ ] 在 `ZiweiSynastryPickScreen.kt` 放置主要按鈕「生成紫微合盤」
    - [ ] 在 `ZiweiSynastryPickScreen.kt` 於點擊觸發與 V18.0 相同權益檢查
    - [ ] 在 `ZiweiSynastryPickScreen.kt` 於通過後排程 `ZiweiSynastryWorker`
  - [ ] 付費沿用
    - [ ] 在 `ZiweiSynastryPickScreen.kt` 使用 `SYNASTRY_DEEP_ONE` 與 `SYNASTRY_BUNDLE_5`
    - [ ] 在 `ZiweiSynastryPickScreen.kt` 使用相同解鎖條與購買流程
  - [ ] 測試
    - [ ] 在 `:core/ziwei` 建立 `ZiweiSynastryTest.kt`
    - [ ] 在 `ZiweiSynastryTest.kt` 測試同宮加分大於 0
    - [ ] 在 `ZiweiSynastryTest.kt` 測試四化衝突減分小於 0
    - [ ] 在 `:app/ui/screens/synastry` 建立 `ZiweiSynastryUiTest.kt`
    - [ ] 在 `ZiweiSynastryUiTest.kt` 測試選擇 → 權益 → 排程流程
- [ ] V16.2 合盤（八字）AI 報告
  - [ ] 服務與演算法
    - [ ] 在 `:core/bazi` 建立 `BaziSynastry.kt`
    - [ ] 在 `BaziSynastry.kt` 定義 `data class TenGodCompat(val god:String,val score:Int,val reason:String)`
    - [ ] 在 `BaziSynastry.kt` 定義 `fun compare(a:BaziChart,b:BaziChart):Pair<Int,List<TenGodCompat>>`
    - [ ] 在 `BaziSynastry.kt` 實作日主五行相生相剋分數
    - [ ] 在 `BaziSynastry.kt` 實作十神關係匹配分數
  - [ ] AI 模板
    - [ ] 在 `:core/ai` 建立 `BaziSynastryPromptBuilder.kt`
    - [ ] 在 `BaziSynastryPromptBuilder.kt` 定義 `fun build(total:Int,details:List<TenGodCompat>,locale:Locale):String`
    - [ ] 在 `BaziSynastryPromptBuilder.kt` 插入段落 `整體匹配`
    - [ ] 在 `BaziSynastryPromptBuilder.kt` 插入段落 `十神互動`
    - [ ] 在 `BaziSynastryPromptBuilder.kt` 插入段落 `改善建議`
  - [ ] 背景任務
    - [ ] 在 `:app/workers` 建立 `BaziSynastryWorker.kt`
    - [ ] 在 `BaziSynastryWorker.kt` 讀取兩份 `BaziChart`
    - [ ] 在 `BaziSynastryWorker.kt` 呼叫 `BaziSynastry.compare`
    - [ ] 在 `BaziSynastryWorker.kt` 呼叫 `BaziSynastryPromptBuilder.build`
    - [ ] 在 `BaziSynastryWorker.kt` 呼叫 `OnnxLlamaSession.generate` 並寫入 `SynastryReport`
  - [ ] UI 與路由
    - [ ] 在 `NavGraph.kt` 新增常數 `ROUTE_BAZI_SYNASTRY_PICK = "bazi.synastry.pick"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_BAZI_SYNASTRY_PICK){ BaziSynastryPickScreen() }`
    - [ ] 在 `:app/ui/screens/synastry` 建立 `BaziSynastryPickScreen.kt`
    - [ ] 在 `BaziSynastryPickScreen.kt` 放置 A/B Chart 選擇控制
    - [ ] 在 `BaziSynastryPickScreen.kt` 放置主要按鈕「生成八字合盤」
    - [ ] 在 `BaziSynastryPickScreen.kt` 於點擊觸發與 V18.0 相同權益檢查
    - [ ] 在 `BaziSynastryPickScreen.kt` 於通過後排程 `BaziSynastryWorker`
  - [ ] 付費沿用
    - [ ] 在 `BaziSynastryPickScreen.kt` 使用 `SYNASTRY_DEEP_ONE` 與 `SYNASTRY_BUNDLE_5`
    - [ ] 在 `BaziSynastryPickScreen.kt` 使用相同解鎖條與購買流程
  - [ ] 測試
    - [ ] 在 `:core/bazi` 建立 `BaziSynastryTest.kt`
    - [ ] 在 `BaziSynastryTest.kt` 測試相生得分大於相剋時的整體分數
    - [ ] 在 `BaziSynastryTest.kt` 測試十神匹配細節項存在
    - [ ] 在 `:app/ui/screens/synastry` 建立 `BaziSynastryUiTest.kt`
    - [ ] 在 `BaziSynastryUiTest.kt` 測試選擇 → 權益 → 排程流程
- [ ] V17.0 週期提醒（逆行／沖剋／吉日）
  - [ ] 規則定義
    - [ ] 在 `:core/astro` 建立 `ReminderRules.kt`
    - [ ] 在 `ReminderRules.kt` 定義枚舉 `ReminderTopic { Retrograde, HardAspect, GoodDay }`
    - [ ] 在 `ReminderRules.kt` 定義資料類型 `ReminderEvent(date:LocalDate,title:String,desc:String,topic:ReminderTopic)`
    - [ ] 在 `ReminderRules.kt` 定義 `fun computeRetrogrades(range:ClosedRange<LocalDate>):List<ReminderEvent>`
    - [ ] 在 `ReminderRules.kt` 定義 `fun computeHardAspects(range:ClosedRange<LocalDate>):List<ReminderEvent>`
    - [ ] 在 `ReminderRules.kt` 定義 `fun computeGoodDays(range:ClosedRange<LocalDate>):List<ReminderEvent>`
  - [ ] 排程器
    - [ ] 在 `:app/workers` 建立 `ReminderScheduler.kt`
    - [ ] 在 `ReminderScheduler.kt` 定義 `fun scheduleDaily(hour:Int,minute:Int)`
    - [ ] 在 `ReminderScheduler.kt` 定義 `fun cancelAll()`
    - [ ] 在 `ReminderScheduler.kt` 使用 `WorkManager` 建立 `PeriodicWorkRequest`
    - [ ] 在 `:app/workers` 建立 `ReminderWorker.kt`
    - [ ] 在 `ReminderWorker.kt` 讀取使用者選擇的主題
    - [ ] 在 `ReminderWorker.kt` 讀取時段設定
    - [ ] 在 `ReminderWorker.kt` 呼叫 `ReminderRules` 計算當日或近日事件
    - [ ] 在 `ReminderWorker.kt` 發送通知含標題
    - [ ] 在 `ReminderWorker.kt` 發送通知含描述
    - [ ] 在 `ReminderWorker.kt` 設定點擊導向 `reminder.list`
  - [ ] 設定頁面
    - [ ] 在 `:app/ui/navigation/NavGraph.kt` 新增 `ROUTE_REMINDER_SETTINGS = "reminder.settings"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_REMINDER_SETTINGS){ ReminderSettingsScreen() }`
    - [ ] 在 `:app/ui/screens` 建立 `ReminderSettingsScreen.kt`
    - [ ] 在 `ReminderSettingsScreen.kt` 放置 `TopAppBar` 標題「週期提醒」
    - [ ] 在 `ReminderSettingsScreen.kt` 放置 `Switch` 一個控制 `Retrograde`
    - [ ] 在 `ReminderSettingsScreen.kt` 放置 `Switch` 一個控制 `HardAspect`
    - [ ] 在 `ReminderSettingsScreen.kt` 放置 `Switch` 一個控制 `GoodDay`
    - [ ] 在 `ReminderSettingsScreen.kt` 放置時間挑選器一個設定時段
    - [ ] 在 `ReminderSettingsScreen.kt` 放置 `Save` 按鈕一個儲存設定
    - [ ] 在 `ReminderSettingsScreen.kt` 於儲存後呼叫 `ReminderScheduler.scheduleDaily`
  - [ ] ICS 匯出
    - [ ] 在 `:app/export` 建立 `IcsExporter.kt`
    - [ ] 在 `IcsExporter.kt` 定義 `fun export(events:List<ReminderEvent>,file:File):File`
    - [ ] 在 `IcsExporter.kt` 生成 `VCALENDAR` 標頭一條
    - [ ] 在 `IcsExporter.kt` 生成各 `VEVENT` 區塊多條
    - [ ] 在 `IcsExporter.kt` 結尾寫入檔案
    - [ ] 在 `ReminderSettingsScreen.kt` 放置 `OutlinedButton` 一個文案「匯出 .ics」
    - [ ] 在 `ReminderSettingsScreen.kt` 點擊呼叫 `IcsExporter.export`
    - [ ] 在 `ReminderSettingsScreen.kt` 產出後以分享 Intent 分享檔案
  - [ ] 付費邏輯
    - [ ] 在 `:billing` 新增常數 `REMINDER_PACK_ALL = "reminder_pack_all"`
    - [ ] 在 `:billing` 新增常數 `REMINDER_PACK_TOPIC = "reminder_pack_topic"`
    - [ ] 在 `:billing` 新增常數 `REMINDER_MONTH_PASS = "reminder_month_pass"`
    - [ ] 在 設定頁檢查 `isVIP` 為真時解鎖全部主題
    - [ ] 在 設定頁檢查 `REMINDER_MONTH_PASS` 有效時解鎖全部主題
    - [ ] 在 設定頁缺少權益時顯示購買按鈕
    - [ ] 在 購買按鈕點擊呼叫對應 `BillingManager.launchPurchase`
  - [ ] 測試
    - [ ] 在 單元測試 `ReminderRulesTest.kt` 驗證三種事件非空
    - [ ] 在 單元測試 `IcsExporterTest.kt` 驗證輸出包含 `VCALENDAR`
    - [ ] 在 UI 測試 `ReminderSettingsUiTest.kt` 驗證開關與時間儲存
    - [ ] 在 手動測試排程通知準時顯示
- [ ] V18.0 神明拜拜系統（為 V19 抽籤整合預備 UI/資料結構）
  - [ ] 資產與資料結構（擴充以支援「籤筒」與神明對應）
    - [ ] 在 `:app/src/main/assets/altar` 建立/擴充 `AltarTheme.json` 增加 `lotTube` 區塊（點位與尺寸）
    - [ ] 在 `AltarTheme.json` 新增欄位 `{"id":"basic","name":"經典","bg":"#...","items":[{"type":"table","x":...,"y":...},{"type":"incense","x":...,"y":...},{"type":"lot_tube","x":0.72,"y":0.48,"w":0.12,"h":0.24,"tapTarget":"lot_tube"}]}`
    - [ ] 在 `:data/entity` 建立 `Wish.kt`（`id:String,title:String,notes:String?,createdAt:Instant,due:LocalDate?,status:String,completedAt:Instant?`）
    - [ ] 在 `:data/dao` 建立 `WishDao.kt`（`upsert(entity)`、`get(id)`、`listByStatus(status, limit)`）
    - [ ] 在 `:data/repository` 建立 `WishRepository.kt`（`create/update/toggleComplete/listOpen/listDone`）
    - [ ] 在 `:data/db/migrations` 新增 Wish 表 Migration 並於 `AppDatabase` 註冊
  - [ ] 畫布與主題（加入「籤筒」視覺與可點擊區）
    - [ ] 在 `:app/ui/canvas` 建立 `AltarCanvas.kt`
    - [ ] 在 `AltarCanvas.kt` 使用 `Canvas` 繪製背景/供桌/燭台/香爐
    - [ ] 在 `AltarCanvas.kt` 新增 `drawLotTube(area: Rect)` 畫出籤筒（簡化矩形+陰影）
    - [ ] 在 `AltarCanvas.kt` 將 `lot_tube` 的 `x/y/w/h`（相對比例）轉實際像素 Rect 傳入 `drawLotTube`
    - [ ] 在 `AltarCanvas.kt` 暴露 `onTap(hit:String?)` 回呼（點擊命中 `tapTarget` 回拋）
    - [ ] 在 `:app/ui/altar` 建立 `AltarThemeLoader.kt`，讀取 `AltarTheme.json` 回傳 `AltarTheme`（含 `items` 與 `lot_tube` 定義）
    - [ ] 在 `:app/ui/altar` 建立 `ThemeSelectorSheet.kt` 顯示主題清單（預覽圖/名稱/套用按鈕）
  - [ ] 路由與畫面（保留「籤筒」點擊事件，V17 會掛上抽籤流程）
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_ALTAR = "altar"`
    - [ ] 在 `:app/ui/screens/altar` 建立 `AltarScreen.kt`
    - [ ] 在 `AltarScreen.kt` 置頂 `TopAppBar` 標題「拜拜」
    - [ ] 在 `AltarScreen.kt` 上半部顯示 `AltarCanvas(theme)` 並接 `onTap`
    - [ ] 在 `AltarScreen.kt` 下半部顯示「願望簿」清單與 FAB「新增願望」
    - [ ] 在 `AltarScreen.kt` 點選清單項可切換完成/編輯備註
    - [ ] 在 `AltarScreen.kt` 溢位選單提供「更換主題」按鈕開啟 `ThemeSelectorSheet`
    - [ ] 在 `AltarScreen.kt` 接收 `onTap("lot_tube")` 先以 `Snackbar` 顯示「抽籤將於下一版開放」（V17 接手綁定抽籤）
  - [ ] 提醒與通知
    - [ ] 在 `:app/workers` 建立 `AltarReminderWorker.kt`（每日固定時間推播「上香祈福」）
    - [ ] 在 `NotificationHelper` 新增頻道 `ALTAR_REMINDER`
    - [ ] 在 `SettingsScreen` 新增「每日提醒」開關與時間挑選器，變更後排程/取消 `AltarReminderWorker`
  - [ ] 付費（沿用）
    - [ ] 在 `:billing` 新增 `THEME_PACK_*` SKU 常數清單
    - [ ] 在 `ThemeSelectorSheet.kt` 非 VIP 主題顯示鎖頭與「購買主題」按鈕
    - [ ] 在 「購買主題」呼叫 `BillingManager.launchPurchase(themePackSku)`
    - [ ] 在 VIP 狀態顯示「VIP 免廣告」標籤（沿用 Ads 管控）
  - [ ] 測試
    - [ ] 在 UI 測試：切換主題即時生效且重啟後保持
    - [ ] 在 單元測試：`WishDao` CRUD 與排序
    - [ ] 在 推播測試：每日提醒觸發與點擊導向 `ROUTE_ALTAR`
    - [ ] 在 點擊測試：點擊 `lot_tube` 命中回呼且顯示 `Snackbar`
- [ ] V19.0 AI 求籤詩 + 解籤（整合於 V18 拜拜系統之「籤筒」，亦支援外部籤詩輸入）
  - [ ] 資產與資料層（多神明籤庫與讀數資料表）
    - [ ] 在 `:app/src/main/assets/lots` 建立總目錄
    - [ ] 在 `:app/src/main/assets/lots` 建立 `LotCatalog.json`（宣告可用籤庫與對應神明/寺廟）
    - [ ] 在 `LotCatalog.json` 定義 `{"deities":[{"id":"guanyin","name":"觀音","temples":[{"id":"default","name":"通用觀音籤","range":100,"db":"guanyin/db.json"}]},{"id":"yuelao","name":"月老","temples":[{"id":"default","name":"通用月老籤","range":60,"db":"yuelao/db.json"}]}]}`
    - [ ] 在 `:app/src/main/assets/lots/guanyin` 建立 `db.json`（1~100 首，`{"id":1,"title":"...","poem":"...","meaning":"...","tier":"上/中/下","tags":["婚姻","財運"]}`）
    - [ ] 在 `:app/src/main/assets/lots/yuelao` 建立 `db.json`（1~60 首，同上結構）
    - [ ] 在 `:data/entity` 建立 `LotReading.kt`（`id:String, deityId:String, templeId:String, lotId:Int, seed:Long?, question:String?, summary:String?, detailEnc:String?, createdAt:Instant, unlocked:Boolean, paidBy:String?, backupSynced:Boolean`）
    - [ ] 在 `:data/dao` 建立 `LotReadingDao.kt`（`upsert/get/byDeity(list,limit)/recent(limit)`）
    - [ ] 在 `:data/repository` 建立 `LotReadingRepository.kt`（封裝加/解密 `detailEnc` 與 `upsert/get/listRecent`）
    - [ ] 在 `:data/db/migrations` 新增 LotReading 表 Migration 並於 `AppDatabase` 註冊
  - [ ] 服務層與抽籤（依「當前供奉神明」決定籤庫；支援自訂種子）
    - [ ] 在 `:core/lots` 建立 `LotsModels.kt`（`data class Lot(id:Int,title:String,poem:String,meaning:String,tier:String,tags:List<String>)`）
    - [ ] 在 `:core/lots` 建立 `LotCatalog.kt` 載入 `LotCatalog.json` 並提供 `fun defaultTemple(deityId:String): Temple`
    - [ ] 在 `:core/lots` 建立 `LotsRepo.kt` 載入指定 `db.json`，提供 `fun getLot(deityId:String, templeId:String, id:Int): Lot`
    - [ ] 在 `:core/lots` 建立 `LotsService.kt`
    - [ ] 在 `LotsService.kt` 實作 `fun draw(deityId:String, templeId:String, seed:Long?=null): Pair<Int,Long>`（回傳 `lotId` 與最終 `seed`，以 seed 決定 determinism）
    - [ ] 在 `LotsService.kt` 實作 `fun validate(deityId, templeId, lotId): Boolean`（驗證區間）
    - [ ] 在 `:core/lots` 建立 `LotsShareBuilder.kt`（`fun buildShare(reading:LotReading, lot:Lot): String`，避免個資）
    - [ ] 在 `:app/ui/altar` 建立 `DeityResolver.kt`（由 `AltarTheme` 或使用者在 `AltarScreen` 選取當前神明，回傳 `deityId/templeId`）
  - [ ] AI Prompt 與背景生成（同一機制服務內部抽籤與外部輸入）
    - [ ] 在 `:core/ai` 建立 `LotsPromptBuilder.kt`
    - [ ] 在 `LotsPromptBuilder.kt` 實作 `fun build(lot:Lot, deityName:String, templeName:String, question:String?, locale:Locale): String`（含 `[籤意] [適用議題] [建議] [提醒]` 段落與「僅供參考」）
    - [ ] 在 `:app/workers` 建立 `LotReadingWorker.kt`
    - [ ] 在 `LotReadingWorker.kt` 讀取 `readingId` → 取 `LotReading` 與 `Lot` → `OnnxLlamaSession.generate(prompt)` → 加密寫回 `detailEnc` 與填入 `summary`
    - [ ] 在 `LotReadingWorker.kt` 完成後發送通知導向 `lots.result/{id}`
  - [ ] 路由與畫面（整合於 Altar；支援外部籤詩輸入解籤）
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_LOTS_RESULT = "lots.result/{id}"`
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_LOTS_HISTORY = "lots.history"`
    - [ ] 在 `NavGraph.kt` 新增 `ROUTE_LOTS_MANUAL = "lots.manual"`（外部籤詩輸入）
    - [ ] 在 `:app/ui/screens/lots` 建立 `LotsResultScreen.kt`
    - [ ] 在 `LotsResultScreen.kt` 顯示卡片：`籤號/標題/等第(tier)` 與 `poem` 摘要、`summary`（未解鎖則顯示解鎖條）
    - [ ] 在 `LotsResultScreen.kt` 底部主要按鈕「生成 AI 解籤（背景）」；旁放「分享」「儲存」
    - [ ] 在 `LotsResultScreen.kt` 監聽 Worker 狀態；完成後展開長文（已解鎖才可全文）
    - [ ] 在 `:app/ui/screens/lots` 建立 `LotsHistoryScreen.kt`（列表：日期/神明/籤號/摘要，可點進）
    - [ ] 在 `:app/ui/screens/lots` 建立 `LotsManualScreen.kt`
    - [ ] 在 `LotsManualScreen.kt` 放置下拉選擇「神明/寺廟」，數字輸入「籤號」，輸入框「問題（選填）」，主要按鈕「解籤」
    - [ ] 在 `LotsManualScreen.kt` 點擊「解籤」→ 驗證 `lotId` 合法 → 建立 `LotReading`（來源標記 `seed=null`）→ 導向 `LotsResultScreen`
    - [ ] 在 `:app/ui/screens/altar/AltarScreen.kt` 接 `onTap("lot_tube")` 開啟底部抽籤面板
    - [ ] 在 `AltarScreen` 抽籤面板放置：神明/寺廟（預設由 `DeityResolver`）、輸入框「問題（選填）」、Switch「自訂種子」、數字輸入（當 Switch 開啟）、主要按鈕「抽籤」
    - [ ] 在 `AltarScreen` 抽籤面板點擊「抽籤」→ 呼叫 `LotsService.draw` 取得 `(lotId, seed)` → 建立 `LotReading`（含 `deityId/templeId/lotId/seed/question`）→ 導向 `LotsResultScreen`
    - [ ] 在 `AltarScreen` 溢位選單新增「外部籤詩解籤」導向 `ROUTE_LOTS_MANUAL`
    - [ ] 在 `Home` 或 `AltarScreen` 右上加「歷史」圖示導向 `ROUTE_LOTS_HISTORY`（非 Debug，正式可見）
  - [ ] 付費與解鎖（僅 AI 長文需解鎖；抽籤與基本資訊免費）
    - [ ] 在 `:billing` 新增常數 `LOTS_READING_ONE = "lots_reading_one"`
    - [ ] 在 `LotsResultScreen.kt` 若 `isVIP=true` 直接顯示長文
    - [ ] 在 `LotsResultScreen.kt` 若 `isVIP=false` 且 `reading.unlocked=false` 顯示解鎖條（「用 50 幣解鎖」「單次購買」）
    - [ ] 在 「用 50 幣解鎖」呼叫 `CoinsService.spend(50)` 成功→`reading.unlocked=true`→刷新
    - [ ] 在 「單次購買」呼叫 `BillingManager.launchPurchase(LOTS_READING_ONE)` 成功→`reading.unlocked=true`
    - [ ] 在 已解鎖再次查看同一筆 `reading` 不重扣
  - [ ] 雲備份（選配，VIP 專屬）
    - [ ] 在 `:sync/DriveService.kt` 新增 `lots.json` 同步檔支援（遵循 AppFolder）
    - [ ] 在 `SyncRepository` 新增 `syncLots()` 合併策略（`updatedAt` 新者覆蓋）
    - [ ] 在 `SettingsScreen` 新增「同步籤詩讀數」開關（僅 VIP 顯示）
    - [ ] 在 讀數變更後排程 `SyncRepository.syncLots()`（若啟用）
  - [ ] 分享與隱私
    - [ ] 在 `LotsShareBuilder.kt` 產出分享文：`神明/寺廟/籤號/標題/要旨/（可選）我的問題`（預設隱藏問題，需勾選才包含）
    - [ ] 在 `LotsResultScreen.kt` 點擊「分享」觸發分享 Intent（僅文字，不含個資）
  - [ ] 單元測試
    - [ ] 在 `:core/lots/test` 建立 `LotsServiceTest.kt` 驗證固定 `seed` 於同 `deity/temple` 得到相同 `lotId`
    - [ ] 在 `LotsServiceTest.kt` 驗證 `validate()` 對越界籤號回傳 `false`
    - [ ] 在 `:core/ai/test` 建立 `LotsPromptBuilderTest.kt` 驗證模板包含段落 `[籤意][適用議題][建議][提醒]`
    - [ ] 在 `:data/test` 建立 `LotReadingDaoTest.kt` 驗證 `upsert/get/recent` 正常
  - [ ] UI 測試
    - [ ] 在 `AltarScreenTest.kt` 測試點擊籤筒→開啟抽籤面板→抽籤→導向結果頁
    - [ ] 在 `LotsManualScreenTest.kt` 測試外部籤詩輸入→結果頁
    - [ ] 在 `LotsResultScreenTest.kt` 測試未解鎖顯示解鎖條→用幣解鎖→生成→展開長文
    - [ ] 在 `LotsHistoryScreenTest.kt` 測試列表點擊進入既有讀數
  - [ ] 效能與體驗
    - [ ] 在 `LotsResultScreen` 長文渲染於 `LazyColumn` 分段（避免一次性重排）
    - [ ] 在 抽籤面板抽籤時顯示 1.2 秒簡短抽動動畫（不加入 Debug 控制）
    - [ ] 在 低 RAM 模擬器測試切換/返回流程不卡頓
  - [ ] 無 Debug-only 控制檢查
    - [ ] 檢查所有畫面無隱藏入口/測試按鈕
    - [ ] 抽籤與解籤流程與 Release 版一致
- [ ] V20.0 行動教練模式（To-Do 生成、日程推送）
  - [ ] 資料結構
    - [ ] 在 `:data/entity` 建立 `CoachTask.kt`
    - [ ] 在 `CoachTask.kt` 定義 `data class CoachTask(id:String,title:String,desc:String?,due:LocalDate?,priority:Int,status:String,createdAt:Instant,completedAt:Instant?)`
    - [ ] 在 `:data/dao` 建立 `CoachTaskDao.kt`
    - [ ] 在 `CoachTaskDao.kt` 定義 `upsert(task:CoachTask)`
    - [ ] 在 `CoachTaskDao.kt` 定義 `listOpen():List<CoachTask>`
    - [ ] 在 `CoachTaskDao.kt` 定義 `complete(id:String,completedAt:Instant)`
    - [ ] 在 `:data/repository` 建立 `CoachTaskRepository.kt`
  - [ ] 教練引擎
    - [ ] 在 `:core/coach` 建立 `CoachEngine.kt`
    - [ ] 在 `CoachEngine.kt` 定義 `fun extractGoals(reports:List<Report>):List<String>`
    - [ ] 在 `CoachEngine.kt` 定義 `fun planActions(goals:List<String>):List<CoachTask>`
    - [ ] 在 `CoachEngine.kt` 使用關鍵詞規則建立 30 日清單
  - [ ] 對話流程
    - [ ] 在 `:app/ui/navigation/NavGraph.kt` 新增 `ROUTE_COACH_SESSION = "coach.session"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_COACH_SESSION){ CoachSessionScreen() }`
    - [ ] 在 `:app/ui/screens/coach` 建立 `CoachSessionScreen.kt`
    - [ ] 在 `CoachSessionScreen.kt` 放置對話訊息列表
    - [ ] 在 `CoachSessionScreen.kt` 放置輸入框
    - [ ] 在 `CoachSessionScreen.kt` 放置送出按鈕
    - [ ] 在 `CoachSessionScreen.kt` 使用輸入觸發 `CoachEngine.extractGoals`
    - [ ] 在 `CoachSessionScreen.kt` 顯示系統生成的任務建議
    - [ ] 在 `CoachSessionScreen.kt` 提供「加入清單」按鈕
    - [ ] 在 `CoachSessionScreen.kt` 於按下加入寫入 `CoachTaskRepository`
  - [ ] 任務提醒
    - [ ] 在 `:app/workers` 建立 `CoachDailyWorker.kt`
    - [ ] 在 `CoachDailyWorker.kt` 每日推送待辦摘要
    - [ ] 在 `:app/workers` 建立 `CoachWeeklyWorker.kt`
    - [ ] 在 `CoachWeeklyWorker.kt` 每週推送回顧摘要
    - [ ] 在 `NotificationHelper` 新增頻道 `COACH_DAILY`
    - [ ] 在 `NotificationHelper` 新增頻道 `COACH_WEEKLY`
  - [ ] 付費
    - [ ] 在 `:billing` 新增常數 `COACH_SESSION_ONE = "coach_session_one"`
    - [ ] 在 `:billing` 新增常數 `COACH_MONTH_PASS = "coach_month_pass"`
    - [ ] 在 `CoachSessionScreen.kt` 檢查 `isVIP` 或 `COACH_MONTH_PASS` 有效
    - [ ] 在 `CoachSessionScreen.kt` 權益不足顯示解鎖條
    - [ ] 在 `CoachSessionScreen.kt` 解鎖條提供「購買單次」按鈕
    - [ ] 在 `CoachSessionScreen.kt` 解鎖條提供「購買月票」按鈕
  - [ ] 測試
    - [ ] 在 單元測試 `CoachEngineTest.kt` 驗證目標抽取至少 3 條
    - [ ] 在 單元測試 `CoachTaskDaoTest.kt` 驗證 CRUD 正確
    - [ ] 在 UI 測試 `CoachSessionUiTest.kt` 驗證對話到建立任務流暢
- [ ] V21.0 市集主題（盤面皮膚）
  - [ ] 資產
    - [ ] 在 `:app/src/main/assets/theme` 建立 `ThemeStore.json`
    - [ ] 在 `ThemeStore.json` 定義欄位 `{"id":"classic","name":"經典","primary":"#...","secondary":"#...","bg":"#...","priceSku":"theme_pack_classic","preview":"theme/classic_preview.png"}`
    - [ ] 在 `:app/src/main/assets/theme` 放置預覽圖 `classic_preview.png`
  - [ ] 主題管理
    - [ ] 在 `:core/theme` 建立 `ThemeManager.kt`
    - [ ] 在 `ThemeManager.kt` 定義 `fun loadAll(context:Context):List<AppTheme>`
    - [ ] 在 `ThemeManager.kt` 定義 `fun apply(theme:AppTheme)`
    - [ ] 在 `ThemeManager.kt` 定義 `fun current():AppTheme`
    - [ ] 在 `ThemeManager.kt` 使用 DataStore 儲存 `currentThemeId`
  - [ ] 路由與畫面
    - [ ] 在 `:app/ui/navigation/NavGraph.kt` 新增 `ROUTE_THEME_STORE = "theme.store"`
    - [ ] 在 `NavGraph.kt` 新增 `composable(ROUTE_THEME_STORE){ ThemeStoreScreen() }`
    - [ ] 在 `:app/ui/screens/theme` 建立 `ThemeStoreScreen.kt`
    - [ ] 在 `ThemeStoreScreen.kt` 顯示主題清單
    - [ ] 在 `ThemeStoreScreen.kt` 顯示每個主題預覽縮圖
    - [ ] 在 `ThemeStoreScreen.kt` 顯示每個主題名稱
    - [ ] 在 `ThemeStoreScreen.kt` 顯示每個主題「試用」按鈕
    - [ ] 在 `ThemeStoreScreen.kt` 顯示每個主題「購買」按鈕
    - [ ] 在 `ThemeStoreScreen.kt` 點擊「試用」即時套用暫時主題
    - [ ] 在 `ThemeStoreScreen.kt` 點擊「購買」啟動結帳流程
    - [ ] 在 `ThemeStoreScreen.kt` 顯示「已擁有」標籤於已購買主題
  - [ ] 付費與權益
    - [ ] 在 `:billing` 新增常數 `THEME_ALL_ACCESS = "theme_all_access"`
    - [ ] 在 `:billing` 新增常數 `THEME_PACK_CLASSIC = "theme_pack_classic"`
    - [ ] 在 `:billing` 新增常數 `THEME_PACK_*` 其餘主題 SKU
    - [ ] 在 `ThemeStoreScreen.kt` 檢查 `isVIP` 為真時顯示「已擁有全部」
    - [ ] 在 `ThemeStoreScreen.kt` 檢查 `THEME_ALL_ACCESS` 有效時顯示「已擁有全部」
    - [ ] 在 `ThemeStoreScreen.kt` 單主題購買成功後標記擁有
    - [ ] 在 `ThemeStoreScreen.kt` `THEME_ALL_ACCESS` 購買成功後標記全部擁有
    - [ ] 在 `ThemeStoreScreen.kt` 提供「以 100 幣兌換」按鈕（非 VIP）
    - [ ] 在 `ThemeStoreScreen.kt` 於兌換點擊呼叫 `CoinsService.spend(100)`
    - [ ] 在 `ThemeStoreScreen.kt` 於兌換成功後標記擁有
  - [ ] 熱切換與回退
    - [ ] 在 `ThemeManager.kt` 套用時更新 `MaterialTheme` 顏色
    - [ ] 在 `ThemeManager.kt` 套用時刷新根 Composable
    - [ ] 在 `ThemeManager.kt` 提供 `fun preview(appTheme:AppTheme,content:@Composable()->Unit)` 區域預覽
    - [ ] 在 `ThemeStoreScreen.kt` 試用結束還原 `currentThemeId`
    - [ ] 在 `ThemeStoreScreen.kt` 應用購買主題後更新 `currentThemeId`
  - [ ] 測試
    - [ ] 在 單元測試 `ThemeManagerTest.kt` 驗證載入主題數量
    - [ ] 在 單元測試 `ThemeManagerTest.kt` 驗證持久化 `currentThemeId`
    - [ ] 在 UI 測試 `ThemeStoreUiTest.kt` 驗證試用後回退
    - [ ] 在 UI 測試 `ThemeStoreUiTest.kt` 驗證購買後持久套用
- [ ] 上架流程（每次版本上架固定步驟）
  - [ ] 版本與分支準備
    - [ ] 在 WindSurf 開啟專案根目錄
    - [ ] 切換至 `release/x.y.z` 分支
    - [ ] 在 `app/build.gradle.kts` 更新 `versionCode`（+1）
    - [ ] 在 `app/build.gradle.kts` 更新 `versionName`（x.y.z）
    - [ ] 在 `CHANGELOG.md` 新增 x.y.z 版本變更項
    - [ ] 提交變更 `chore(release): bump to x.y.z`
    - [ ] 推送分支至遠端
  - [ ] 商店頁面：短描述（繁中）
    - [ ] 於 Play Console 開啟對應 App
    - [ ] 進入「商店展示 > 商店資訊 > 短描述」
    - [ ] 貼上繁中短描述（80 字內，含本版核心功能關鍵詞）
    - [ ] 儲存草稿
  - [ ] 商店頁面：短描述（英文）
    - [ ] 切換語言至 English (United States)
    - [ ] 貼上英文短描述（80 字內，對齊繁中要點）
    - [ ] 儲存草稿
  - [ ] 商店頁面：長描述（繁中）
    - [ ] 進入「商店展示 > 商店資訊 > 完整描述」
    - [ ] 更新前三行高密度關鍵詞（含新功能字詞）
    - [ ] 更新中段功能段落（條列新功能與收益）
    - [ ] 更新尾段 CTA（免費試用／VIP／Coins）
    - [ ] 儲存草稿
  - [ ] 商店頁面：長描述（英文）
    - [ ] 切換語言至 English (United States)
    - [ ] 更新前 3 行關鍵詞密度
    - [ ] 更新功能段落與 CTA
    - [ ] 儲存草稿
  - [ ] 關鍵詞對齊檢查
    - [ ] 整理本版新增功能清單
    - [ ] 對照短描述是否包含 1–2 個新功能關鍵詞
    - [ ] 對照長描述是否包含 3–5 個新功能關鍵詞
    - [ ] 對照截圖標題文字是否包含對應關鍵詞
  - [ ] 截圖與影片素材
    - [ ] 啟動 AVD `Pixel6Api35`
    - [ ] 安裝最新 Debug 版並完成新功能場景操作
    - [ ] 擷取 6 張 1080x1920 截圖（核心頁面各 1 張）
    - [ ] 檢查截圖無個資、無 Debug 標記
    - [ ] 若有影片：以裝置錄影 15–30 秒展示新功能
    - [ ] 上傳截圖與影片至 Play Console「商店展示 > 裝置類型 > 手機」
    - [ ] 逐張填寫標題/說明（可選）
  - [ ] Data Safety 檢查
    - [ ] 列出本版新增或移除的第三方 SDK
    - [ ] 檢查資料收集/分享/加密是否有變動
    - [ ] 進入「App 內容 > 資料安全性」
    - [ ] 依實際情況更新資料類型與用途
    - [ ] 儲存並提交更新
  - [ ] 環境清理與簽章檢查
    - [ ] 刪除 `app/build` 舊產物
    - [ ] 檢查 `gradle.properties` 已設定 release 簽章（不入版控）
    - [ ] 檢查 `keystore` 路徑與密碼正確
  - [ ] 產出 AAB（Release）
    - [ ] 開啟終端機
    - [ ] 執行 `./gradlew clean`
    - [ ] 執行 `./gradlew :app:bundleRelease`
    - [ ] 確認輸出 `app/build/outputs/bundle/release/app-release.aab`
    - [ ] 使用 `jarsigner -verify` 驗證簽章成功
  - [ ] Internal 測試上傳
    - [ ] 於 Play Console 進入「發佈 > 測試 > 內部測試」
    - [ ] 建立新版本
    - [ ] 上傳 `app-release.aab`
    - [ ] 於版本說明填入本版重點（繁中與英文）
    - [ ] 儲存並送出內部測試
  - [ ] 測試帳號安裝與驗證
    - [ ] 在測試名單加入測試帳號 Email
    - [ ] 使用測試帳號於 Play 商店安裝內部測試版
    - [ ] 啟動 App 並完成 Onboarding
    - [ ] 進入「排盤」輸入樣本資料並生成星盤
    - [ ] 於「AI 報告」觸發背景生成並等待通知
    - [ ] 於「錢包」點擊「看廣告 +10 幣」完成一次激勵廣告
    - [ ] 使用 50 幣兌換一次深度報告
    - [ ] 於「購買」頁購買一次單次 SKU（測試卡）
    - [ ] 於「設定」點擊「恢復購買」驗證同步權益
    - [ ] 若有同步版本：登入 Google 並觸發雲端同步上/下載
  - [ ] 問題修正與再測
    - [ ] 在 Issue Tracker 記錄測試問題
    - [ ] 逐項修正並提交 PR
    - [ ] 產出新的 `bundleRelease`
    - [ ] 重新上傳至內部測試
    - [ ] 重複安裝與核心流程驗證
  - [ ] 建立 Closed/Open 測試（視需要）
    - [ ] 於 Play Console 建立「封閉測試」軌道
    - [ ] 新增受邀名單或使用 Google 群組
    - [ ] 上傳 `app-release.aab` 至封閉測試
    - [ ] 若需公開測試：建立「公開測試」並設定可見性
  - [ ] 生產版釋出（灰度 10%）
    - [ ] 於「發佈 > 生產」建立新版本
    - [ ] 上傳 `app-release.aab`
    - [ ] 填寫版本更新說明（繁中與英文）
    - [ ] 設定分段釋出比例為 10%
    - [ ] 檢查國家/地區全選或依策略勾選
    - [ ] 送出審核並等待通過
  - [ ] 監控（灰度期間）
    - [ ] 進入「品質 > Android Vitals > ANR & 崩潰」檢查指標
    - [ ] 監看留存（第 1 天/第 7 天）趨勢
    - [ ] 監看評分與評論新增
    - [ ] 若出現高 ANR/崩潰：暫停釋出並回滾
  - [ ] 全量擴大至 100%
    - [ ] 若指標正常，將分段釋出比例調整為 100%
    - [ ] 確認所有地區已納入
    - [ ] 完成生產釋出
  - [ ] 釋出標記與文件
    - [ ] 在 Git 建立 tag `vx.y.z`
    - [ ] 建立 GitHub Release 並貼上變更記錄
    - [ ] 備份 `app-release.aab` 至雲端儲存
    - [ ] 更新專案 Wiki「發佈記錄」
- [ ] AdMob 串接維運（每版檢）
  - [ ] UMP 同意流程
    - [ ] 啟動 App 於 EU/UK 模擬地理（測試裝置）
    - [ ] 驗證開啟時彈出 UMP 同意表單
    - [ ] 同意後檢查廣告可請求
    - [ ] 拒絕後檢查廣告不請求
  - [ ] Rewarded 流程（錢包）
    - [ ] 進入 `WalletScreen`
    - [ ] 點擊「看廣告 +10 幣」
    - [ ] 驗證觸發 `AdsManager.showRewarded()`
    - [ ] 完播後驗證觸發 `onUserEarnedReward`
    - [ ] 檢查 `CoinsService.earn(10)` 被呼叫
  - [ ] 冷卻與上限
    - [ ] 在 1 小時內連續播放第 4 支廣告
    - [ ] 驗證顯示「冷卻中」提示
    - [ ] 在同日播放第 9 支廣告
    - [ ] 验證顯示「達到每日上限」提示
  - [ ] 半途離開防濫用
    - [ ] 在廣告中途關閉
    - [ ] 驗證未發幣
  - [ ] app-ads.txt 檢查
    - [ ] 連線至 GitHub Pages 網站
    - [ ] 開啟 `app-ads.txt`
    - [ ] 確認狀態為通過（AdMob 控制台不顯示警告）
- [ ] 訂閱／付費 維運（每版檢）
  - [ ] Play Console SKU 檢查
    - [ ] 開啟「獲利 > 產品 > 內購商品/訂閱」
    - [ ] 檢查各 SKU 價格與可用地區
  - [ ] App 內購流程
    - [ ] 在購買頁選擇一個消耗性商品
    - [ ] 觸發 `BillingManager.launchPurchase(sku)`
    - [ ] 在回呼 `onPurchasesUpdated` 驗證 `PURCHASED` 狀態
    - [ ] 呼叫 `consume` 完成消耗性購買
    - [ ] 在非消耗性或訂閱完成後呼叫 `acknowledge`
    - [ ] 驗證 `EntitlementStore` 權益更新
  - [ ] 恢復購買
    - [ ] 進入設定頁點擊「恢復購買」
    - [ ] 驗證觸發 `queryPurchasesAsync()`
    - [ ] 檢查權益狀態與 UI 同步
  - [ ] 同步版本（若啟用）
    - [ ] 觸發寫入 `purchases.json`
    - [ ] 上傳至 Drive App Folder
    - [ ] 重新安裝 App 後登入同帳號檢查恢復
- [ ] 隱私與法遵（每版檢）
  - [ ] 商標詞檢查
    - [ ] 檢查 App 內文是否出現限制性商標詞
    - [ ] 檢查商店頁是否出現限制性商標詞
  - [ ] 警語呈現
    - [ ] 在 AI 報告頁顯示「僅供參考」警語
    - [ ] 在 占卜/運勢頁顯示「非專業建議」警語
  - [ ] 隱私政策
    - [ ] 更新第三方 SDK 清單
    - [ ] 更新資料用途與保留說明
    - [ ] 部署至 GitHub Pages
  - [ ] 兒少保護
    - [ ] 檢查分級不面向 13 歲以下
    - [ ] 確認未啟用兒童定向廣告
  - [ ] 同意彈窗
    - [ ] 驗證啟動時如需彈出 UMP
    - [ ] 驗證隱私設定頁可重新管理同意
- [ ] 測試與品質（每版）
  - [ ] 單元測試
    - [ ] 執行 `./gradlew :core:astro:test`
    - [ ] 執行 `./gradlew :core:ai:test`
    - [ ] 執行 `./gradlew :app:test`（含 `CoinsService`、`BillingManager`）
  - [ ] 整合測試（本機）
    - [ ] 啟動 App 完成排盤
    - [ ] 觸發 AI 報告背景生成
    - [ ] 收到通知並進入報告詳頁
    - [ ] 以 Coins 解鎖一次內容
  - [ ] 整合測試（同步版）
    - [ ] 於裝置 A 建立新報告
    - [ ] 於裝置 B 登入同帳號
    - [ ] 檢查合併策略與最新覆蓋
  - [ ] 相容性測試
    - [ ] 在 API 26 執行核心流程
    - [ ] 在 API 28 執行核心流程
    - [ ] 在 API 30 執行核心流程
    - [ ] 在 API 33 執行核心流程
    - [ ] 在 API 35 執行核心流程
  - [ ] 效能測量
    - [ ] 設定 Prompt 生成 700 tokens
    - [ ] 記錄完成時間（ms）
    - [ ] 設定 Prompt 生成 1200 tokens
    - [ ] 記錄完成時間（ms）
    - [ ] 建立基準表（與上一版比較）
  - [ ] 安全驗證
    - [ ] 校驗模型檔 SHA-256 與清單
    - [ ] 驗證資料庫 AES-GCM 解/加密流程
  - [ ] 反濫用檢查
    - [ ] 模擬廣告中途退出
    - [ ] 檢查不發幣
    - [ ] 模擬超過冷卻與上限
    - [ ] 檢查正確阻擋
- [ ] ASO 與素材（每版）
  - [ ] 關鍵詞調整（短描述）
    - [ ] 產生繁中短描述 1 版
    - [ ] 產生英文短描述 1 版
    - [ ] 檢查是否包含新功能關鍵詞
  - [ ] 長描述前三行
    - [ ] 調整繁中前三行關鍵詞密度
    - [ ] 調整英文前三行關鍵詞密度
  - [ ] 截圖產出
    - [ ] 以最新 UI 重新擷取 6 張截圖
    - [ ] 檢查裝置框/陰影一致性
  - [ ] 圖示與授權
    - [ ] 檢查 Icon 與插圖授權來源
    - [ ] 確認可商用授權檔在庫
  - [ ] 多語驗證
    - [ ] 切換 App 至英文語系檢查文案
    - [ ] 切換 App 至繁中語系檢查文案
- [ ] 發行後監控（每版）
  - [ ] 48 小時內監控
    - [ ] 每 6 小時檢查 ANR 比率
    - [ ] 每 6 小時檢查崩潰比率
    - [ ] 檢查用戶評分與新評論
  - [ ] 評分策略
    - [ ] 若平均評分 ≥ 4.5：維持現行 ASO 關鍵詞
    - [ ] 若平均評分 < 4：新增新手引導與提示
  - [ ] 相容性更新
    - [ ] 僅合併必要相容性修正 PR
    - [ ] 檢查影響功能面清單
  - [ ] 快速補丁
    - [ ] 建立 `hotfix/x.y.z+1` 分支
    - [ ] 修正嚴重錯誤
    - [ ] 更新 `versionCode` 與 `versionName`
    - [ ] 產出 `bundleRelease`
    - [ ] 走內部測試 → 生產 10% → 全量流程